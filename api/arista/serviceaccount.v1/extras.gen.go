// Copyright (c) 2023 Arista Networks, Inc.  All rights reserved.
// Use of this source code is governed by the Apache License 2.0
// that can be found in the COPYING file.

//
// Code generated by boomtown. DO NOT EDIT.
//

package serviceaccount

import "google.golang.org/grpc"

// Client composes the service clients within the serviceaccount package.
// This client can then be composed into a larger hierarchy for more complex clients.
//
// Because method names include the name of the Resource they operate on, the embedded
// clients are unnamed fields to reduce stutter.
//
// Included resources:
//   - Account
//   - AccountConfig
//   - Token
//   - TokenConfig
type Client struct {
	Account       AccountServiceClient
	AccountConfig AccountConfigServiceClient
	Token         TokenServiceClient
	TokenConfig   TokenConfigServiceClient
}

// NewClient creates a new composed-client from the given connection.
func NewClient(conn grpc.ClientConnInterface) Client {
	return Client{
		Account:       NewAccountServiceClient(conn),
		AccountConfig: NewAccountConfigServiceClient(conn),
		Token:         NewTokenServiceClient(conn),
		TokenConfig:   NewTokenConfigServiceClient(conn),
	}
}

// Server aggregates the various server interfaces required by gRPC.
// The included resources are:
//   - Account
//   - AccountConfig
//   - Token
//   - TokenConfig
type Server struct {
	Account       AccountServiceServer
	AccountConfig AccountConfigServiceServer
	Token         TokenServiceServer
	TokenConfig   TokenConfigServiceServer
}

// Register takes the given gRPC Server and registers our services with it.
func (s Server) Register(target *grpc.Server) {
	RegisterAccountServiceServer(target, s.Account)
	RegisterAccountConfigServiceServer(target, s.AccountConfig)
	RegisterTokenServiceServer(target, s.Token)
	RegisterTokenConfigServiceServer(target, s.TokenConfig)
}

// RegisterUnimplementeds adds unimplemented servers to the given gRPC Server
func RegisterUnimplementeds(target *grpc.Server) error {
	RegisterAccountServiceServer(target,
		UnimplementedAccountServiceServer{})
	RegisterAccountConfigServiceServer(target,
		UnimplementedAccountConfigServiceServer{})
	RegisterTokenServiceServer(target,
		UnimplementedTokenServiceServer{})
	RegisterTokenConfigServiceServer(target,
		UnimplementedTokenConfigServiceServer{})
	return nil
}

// HasKey returns whether the given Account has a key provided in the model.
func (a *Account) HasKey() bool {
	return a.GetKey() != nil
}

// HasKey returns whether the given AccountRequest has a key provided in the request.
func (a *AccountRequest) HasKey() bool {
	return a.GetKey() != nil
}

// HasKey returns whether the given AccountConfig has a key provided in the model.
func (a *AccountConfig) HasKey() bool {
	return a.GetKey() != nil
}

// HasKey returns whether the given AccountConfigRequest has a key provided in the request.
func (a *AccountConfigRequest) HasKey() bool {
	return a.GetKey() != nil
}

// HasKey returns whether the given AccountConfigSetRequest has a key provided in the request.
func (a *AccountConfigSetRequest) HasKey() bool {
	return a.GetValue().HasKey()
}

// HasKey returns whether the given AccountConfigDeleteRequest has a key provided in the request.
func (a *AccountConfigDeleteRequest) HasKey() bool {
	return a.GetKey() != nil
}

// HasKey returns whether the given Token has a key provided in the model.
func (t *Token) HasKey() bool {
	return t.GetKey() != nil
}

// HasKey returns whether the given TokenRequest has a key provided in the request.
func (t *TokenRequest) HasKey() bool {
	return t.GetKey() != nil
}

// HasKey returns whether the given TokenConfig has a key provided in the model.
func (t *TokenConfig) HasKey() bool {
	return t.GetKey() != nil
}

// HasKey returns whether the given TokenConfigRequest has a key provided in the request.
func (t *TokenConfigRequest) HasKey() bool {
	return t.GetKey() != nil
}

// HasKey returns whether the given TokenConfigSetRequest has a key provided in the request.
func (t *TokenConfigSetRequest) HasKey() bool {
	return t.GetValue().HasKey()
}

// HasKey returns whether the given TokenConfigDeleteRequest has a key provided in the request.
func (t *TokenConfigDeleteRequest) HasKey() bool {
	return t.GetKey() != nil
}

// PassesPartialEqFilter returns whether this AccountStatus matches the comparison. If the given
// argument is unitialized, it is considered a match.
func (a AccountStatus) PassesPartialEqFilter(cmp AccountStatus) bool {
	if cmp != AccountStatus(0) {
		return a == cmp
	}
	return true
}

// PassesPartialEqFilter returns whether the AccountKey matches the passed in filter.
// On a nil comparison, we consider it a pass. Otherwise, all set (non-nil, initialized)
// fields are expected to match their "sibling" field in the comparison. Any non-matching
// value is considered a mismatch of the filter.
func (a *AccountKey) PassesPartialEqFilter(cmp *AccountKey) bool {
	// gave nothing to filter on, consider it passing
	if cmp == nil {
		return true
	}

	if a == nil {
		return false
	}

	if cmp.Name != nil {
		if a.Name == nil {
			return false
		}
		if a.Name.Value != cmp.Name.Value {
			return false
		}
	}

	return true
}

// PassesPartialEqFilter returns whether the TokenKey matches the passed in filter.
// On a nil comparison, we consider it a pass. Otherwise, all set (non-nil, initialized)
// fields are expected to match their "sibling" field in the comparison. Any non-matching
// value is considered a mismatch of the filter.
func (t *TokenKey) PassesPartialEqFilter(cmp *TokenKey) bool {
	// gave nothing to filter on, consider it passing
	if cmp == nil {
		return true
	}

	if t == nil {
		return false
	}

	if cmp.Id != nil {
		if t.Id == nil {
			return false
		}
		if t.Id.Value != cmp.Id.Value {
			return false
		}
	}

	return true
}

// PassesPartialEqFilter returns whether the Account matches the passed in filter.
// On a nil comparison, we consider it a pass. Otherwise, all set (non-nil, initialized)
// fields are expected to match their "sibling" field in the comparison. Any non-matching
// value is considered a mismatch of the filter.
func (a *Account) PassesPartialEqFilter(cmp *Account) bool {
	// if the resource is nil, there is nothing to send to the client
	if a == nil {
		return false
	}

	// gave nothing to filter on, consider it passing
	if cmp == nil {
		return true
	}

	if !a.Key.PassesPartialEqFilter(cmp.Key) {
		return false
	}

	if !a.Status.PassesPartialEqFilter(cmp.Status) {
		return false
	}

	if cmp.Description != nil {
		if a.Description == nil {
			return false
		}
		if a.Description.Value != cmp.Description.Value {
			return false
		}
	}

	if !a.Groups.PassesPartialEqFilter(cmp.Groups) {
		return false
	}

	if cmp.CreatedBy != nil {
		if a.CreatedBy == nil {
			return false
		}
		if a.CreatedBy.Value != cmp.CreatedBy.Value {
			return false
		}
	}

	if cmp.LastAccess != nil {
		if cmp.LastAccess.Seconds != 0 {
			if a.LastAccess.Seconds != cmp.LastAccess.Seconds {
				return false
			}
		}
		if cmp.LastAccess.Nanos != 0 {
			if a.LastAccess.Nanos != cmp.LastAccess.Nanos {
				return false
			}
		}
	}

	return true
}

// MatchesAnyPartialEqFilter returns whether the receiver matches any filters in the given set.
func (a *Account) MatchesAnyPartialEqFilter(filters []*Account) bool {
	if len(filters) == 0 {
		return true
	}

	for _, filt := range filters {
		if a.PassesPartialEqFilter(filt) {
			return true
		}
	}

	return false
}

// PassesPartialEqFilter returns whether the AccountConfig matches the passed in filter.
// On a nil comparison, we consider it a pass. Otherwise, all set (non-nil, initialized)
// fields are expected to match their "sibling" field in the comparison. Any non-matching
// value is considered a mismatch of the filter.
func (a *AccountConfig) PassesPartialEqFilter(cmp *AccountConfig) bool {
	// if the resource is nil, there is nothing to send to the client
	if a == nil {
		return false
	}

	// gave nothing to filter on, consider it passing
	if cmp == nil {
		return true
	}

	if !a.Key.PassesPartialEqFilter(cmp.Key) {
		return false
	}

	if !a.Status.PassesPartialEqFilter(cmp.Status) {
		return false
	}

	if cmp.Description != nil {
		if a.Description == nil {
			return false
		}
		if a.Description.Value != cmp.Description.Value {
			return false
		}
	}

	if !a.Groups.PassesPartialEqFilter(cmp.Groups) {
		return false
	}

	return true
}

// MatchesAnyPartialEqFilter returns whether the receiver matches any filters in the given set.
func (a *AccountConfig) MatchesAnyPartialEqFilter(filters []*AccountConfig) bool {
	if len(filters) == 0 {
		return true
	}

	for _, filt := range filters {
		if a.PassesPartialEqFilter(filt) {
			return true
		}
	}

	return false
}

// PassesPartialEqFilter returns whether the Token matches the passed in filter.
// On a nil comparison, we consider it a pass. Otherwise, all set (non-nil, initialized)
// fields are expected to match their "sibling" field in the comparison. Any non-matching
// value is considered a mismatch of the filter.
func (t *Token) PassesPartialEqFilter(cmp *Token) bool {
	// if the resource is nil, there is nothing to send to the client
	if t == nil {
		return false
	}

	// gave nothing to filter on, consider it passing
	if cmp == nil {
		return true
	}

	if !t.Key.PassesPartialEqFilter(cmp.Key) {
		return false
	}

	if cmp.User != nil {
		if t.User == nil {
			return false
		}
		if t.User.Value != cmp.User.Value {
			return false
		}
	}

	if cmp.Description != nil {
		if t.Description == nil {
			return false
		}
		if t.Description.Value != cmp.Description.Value {
			return false
		}
	}

	if cmp.ValidUntil != nil {
		if cmp.ValidUntil.Seconds != 0 {
			if t.ValidUntil.Seconds != cmp.ValidUntil.Seconds {
				return false
			}
		}
		if cmp.ValidUntil.Nanos != 0 {
			if t.ValidUntil.Nanos != cmp.ValidUntil.Nanos {
				return false
			}
		}
	}

	if cmp.CreatedBy != nil {
		if t.CreatedBy == nil {
			return false
		}
		if t.CreatedBy.Value != cmp.CreatedBy.Value {
			return false
		}
	}

	if cmp.LastUsed != nil {
		if cmp.LastUsed.Seconds != 0 {
			if t.LastUsed.Seconds != cmp.LastUsed.Seconds {
				return false
			}
		}
		if cmp.LastUsed.Nanos != 0 {
			if t.LastUsed.Nanos != cmp.LastUsed.Nanos {
				return false
			}
		}
	}

	return true
}

// MatchesAnyPartialEqFilter returns whether the receiver matches any filters in the given set.
func (t *Token) MatchesAnyPartialEqFilter(filters []*Token) bool {
	if len(filters) == 0 {
		return true
	}

	for _, filt := range filters {
		if t.PassesPartialEqFilter(filt) {
			return true
		}
	}

	return false
}

// PassesPartialEqFilter returns whether the TokenConfig matches the passed in filter.
// On a nil comparison, we consider it a pass. Otherwise, all set (non-nil, initialized)
// fields are expected to match their "sibling" field in the comparison. Any non-matching
// value is considered a mismatch of the filter.
func (t *TokenConfig) PassesPartialEqFilter(cmp *TokenConfig) bool {
	// if the resource is nil, there is nothing to send to the client
	if t == nil {
		return false
	}

	// gave nothing to filter on, consider it passing
	if cmp == nil {
		return true
	}

	if !t.Key.PassesPartialEqFilter(cmp.Key) {
		return false
	}

	if cmp.User != nil {
		if t.User == nil {
			return false
		}
		if t.User.Value != cmp.User.Value {
			return false
		}
	}

	if cmp.Description != nil {
		if t.Description == nil {
			return false
		}
		if t.Description.Value != cmp.Description.Value {
			return false
		}
	}

	if cmp.ValidFor != nil {
		if cmp.ValidFor.Seconds != 0 {
			if t.ValidFor.Seconds != cmp.ValidFor.Seconds {
				return false
			}
		}
		if cmp.ValidFor.Nanos != 0 {
			if t.ValidFor.Nanos != cmp.ValidFor.Nanos {
				return false
			}
		}
	}

	if cmp.Token != nil {
		if t.Token == nil {
			return false
		}
		if t.Token.Value != cmp.Token.Value {
			return false
		}
	}

	return true
}

// MatchesAnyPartialEqFilter returns whether the receiver matches any filters in the given set.
func (t *TokenConfig) MatchesAnyPartialEqFilter(filters []*TokenConfig) bool {
	if len(filters) == 0 {
		return true
	}

	for _, filt := range filters {
		if t.PassesPartialEqFilter(filt) {
			return true
		}
	}

	return false
}
