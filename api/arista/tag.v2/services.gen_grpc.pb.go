// Code generated by protoc-gen-go-grpc. DO NOT EDIT.

package tag

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

// TagServiceClient is the client API for TagService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type TagServiceClient interface {
	GetOne(ctx context.Context, in *TagRequest, opts ...grpc.CallOption) (*TagResponse, error)
	GetAll(ctx context.Context, in *TagStreamRequest, opts ...grpc.CallOption) (TagService_GetAllClient, error)
	Subscribe(ctx context.Context, in *TagStreamRequest, opts ...grpc.CallOption) (TagService_SubscribeClient, error)
}

type tagServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewTagServiceClient(cc grpc.ClientConnInterface) TagServiceClient {
	return &tagServiceClient{cc}
}

func (c *tagServiceClient) GetOne(ctx context.Context, in *TagRequest, opts ...grpc.CallOption) (*TagResponse, error) {
	out := new(TagResponse)
	err := c.cc.Invoke(ctx, "/arista.tag.v2.TagService/GetOne", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tagServiceClient) GetAll(ctx context.Context, in *TagStreamRequest, opts ...grpc.CallOption) (TagService_GetAllClient, error) {
	stream, err := c.cc.NewStream(ctx, &TagService_ServiceDesc.Streams[0], "/arista.tag.v2.TagService/GetAll", opts...)
	if err != nil {
		return nil, err
	}
	x := &tagServiceGetAllClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type TagService_GetAllClient interface {
	Recv() (*TagStreamResponse, error)
	grpc.ClientStream
}

type tagServiceGetAllClient struct {
	grpc.ClientStream
}

func (x *tagServiceGetAllClient) Recv() (*TagStreamResponse, error) {
	m := new(TagStreamResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *tagServiceClient) Subscribe(ctx context.Context, in *TagStreamRequest, opts ...grpc.CallOption) (TagService_SubscribeClient, error) {
	stream, err := c.cc.NewStream(ctx, &TagService_ServiceDesc.Streams[1], "/arista.tag.v2.TagService/Subscribe", opts...)
	if err != nil {
		return nil, err
	}
	x := &tagServiceSubscribeClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type TagService_SubscribeClient interface {
	Recv() (*TagStreamResponse, error)
	grpc.ClientStream
}

type tagServiceSubscribeClient struct {
	grpc.ClientStream
}

func (x *tagServiceSubscribeClient) Recv() (*TagStreamResponse, error) {
	m := new(TagStreamResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// TagServiceServer is the server API for TagService service.
// All implementations must embed UnimplementedTagServiceServer
// for forward compatibility
type TagServiceServer interface {
	GetOne(context.Context, *TagRequest) (*TagResponse, error)
	GetAll(*TagStreamRequest, TagService_GetAllServer) error
	Subscribe(*TagStreamRequest, TagService_SubscribeServer) error
	mustEmbedUnimplementedTagServiceServer()
}

// UnimplementedTagServiceServer must be embedded to have forward compatible implementations.
type UnimplementedTagServiceServer struct {
}

func (UnimplementedTagServiceServer) GetOne(context.Context, *TagRequest) (*TagResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetOne not implemented")
}
func (UnimplementedTagServiceServer) GetAll(*TagStreamRequest, TagService_GetAllServer) error {
	return status.Errorf(codes.Unimplemented, "method GetAll not implemented")
}
func (UnimplementedTagServiceServer) Subscribe(*TagStreamRequest, TagService_SubscribeServer) error {
	return status.Errorf(codes.Unimplemented, "method Subscribe not implemented")
}
func (UnimplementedTagServiceServer) mustEmbedUnimplementedTagServiceServer() {}

// UnsafeTagServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to TagServiceServer will
// result in compilation errors.
type UnsafeTagServiceServer interface {
	mustEmbedUnimplementedTagServiceServer()
}

func RegisterTagServiceServer(s grpc.ServiceRegistrar, srv TagServiceServer) {
	s.RegisterService(&TagService_ServiceDesc, srv)
}

func _TagService_GetOne_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TagRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TagServiceServer).GetOne(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/arista.tag.v2.TagService/GetOne",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TagServiceServer).GetOne(ctx, req.(*TagRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TagService_GetAll_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(TagStreamRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(TagServiceServer).GetAll(m, &tagServiceGetAllServer{stream})
}

type TagService_GetAllServer interface {
	Send(*TagStreamResponse) error
	grpc.ServerStream
}

type tagServiceGetAllServer struct {
	grpc.ServerStream
}

func (x *tagServiceGetAllServer) Send(m *TagStreamResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _TagService_Subscribe_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(TagStreamRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(TagServiceServer).Subscribe(m, &tagServiceSubscribeServer{stream})
}

type TagService_SubscribeServer interface {
	Send(*TagStreamResponse) error
	grpc.ServerStream
}

type tagServiceSubscribeServer struct {
	grpc.ServerStream
}

func (x *tagServiceSubscribeServer) Send(m *TagStreamResponse) error {
	return x.ServerStream.SendMsg(m)
}

// TagService_ServiceDesc is the grpc.ServiceDesc for TagService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var TagService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "arista.tag.v2.TagService",
	HandlerType: (*TagServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetOne",
			Handler:    _TagService_GetOne_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "GetAll",
			Handler:       _TagService_GetAll_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "Subscribe",
			Handler:       _TagService_Subscribe_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "arista/tag.v2/services.gen.proto",
}

// TagAssignmentServiceClient is the client API for TagAssignmentService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type TagAssignmentServiceClient interface {
	GetOne(ctx context.Context, in *TagAssignmentRequest, opts ...grpc.CallOption) (*TagAssignmentResponse, error)
	GetAll(ctx context.Context, in *TagAssignmentStreamRequest, opts ...grpc.CallOption) (TagAssignmentService_GetAllClient, error)
	Subscribe(ctx context.Context, in *TagAssignmentStreamRequest, opts ...grpc.CallOption) (TagAssignmentService_SubscribeClient, error)
}

type tagAssignmentServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewTagAssignmentServiceClient(cc grpc.ClientConnInterface) TagAssignmentServiceClient {
	return &tagAssignmentServiceClient{cc}
}

func (c *tagAssignmentServiceClient) GetOne(ctx context.Context, in *TagAssignmentRequest, opts ...grpc.CallOption) (*TagAssignmentResponse, error) {
	out := new(TagAssignmentResponse)
	err := c.cc.Invoke(ctx, "/arista.tag.v2.TagAssignmentService/GetOne", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tagAssignmentServiceClient) GetAll(ctx context.Context, in *TagAssignmentStreamRequest, opts ...grpc.CallOption) (TagAssignmentService_GetAllClient, error) {
	stream, err := c.cc.NewStream(ctx, &TagAssignmentService_ServiceDesc.Streams[0], "/arista.tag.v2.TagAssignmentService/GetAll", opts...)
	if err != nil {
		return nil, err
	}
	x := &tagAssignmentServiceGetAllClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type TagAssignmentService_GetAllClient interface {
	Recv() (*TagAssignmentStreamResponse, error)
	grpc.ClientStream
}

type tagAssignmentServiceGetAllClient struct {
	grpc.ClientStream
}

func (x *tagAssignmentServiceGetAllClient) Recv() (*TagAssignmentStreamResponse, error) {
	m := new(TagAssignmentStreamResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *tagAssignmentServiceClient) Subscribe(ctx context.Context, in *TagAssignmentStreamRequest, opts ...grpc.CallOption) (TagAssignmentService_SubscribeClient, error) {
	stream, err := c.cc.NewStream(ctx, &TagAssignmentService_ServiceDesc.Streams[1], "/arista.tag.v2.TagAssignmentService/Subscribe", opts...)
	if err != nil {
		return nil, err
	}
	x := &tagAssignmentServiceSubscribeClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type TagAssignmentService_SubscribeClient interface {
	Recv() (*TagAssignmentStreamResponse, error)
	grpc.ClientStream
}

type tagAssignmentServiceSubscribeClient struct {
	grpc.ClientStream
}

func (x *tagAssignmentServiceSubscribeClient) Recv() (*TagAssignmentStreamResponse, error) {
	m := new(TagAssignmentStreamResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// TagAssignmentServiceServer is the server API for TagAssignmentService service.
// All implementations must embed UnimplementedTagAssignmentServiceServer
// for forward compatibility
type TagAssignmentServiceServer interface {
	GetOne(context.Context, *TagAssignmentRequest) (*TagAssignmentResponse, error)
	GetAll(*TagAssignmentStreamRequest, TagAssignmentService_GetAllServer) error
	Subscribe(*TagAssignmentStreamRequest, TagAssignmentService_SubscribeServer) error
	mustEmbedUnimplementedTagAssignmentServiceServer()
}

// UnimplementedTagAssignmentServiceServer must be embedded to have forward compatible implementations.
type UnimplementedTagAssignmentServiceServer struct {
}

func (UnimplementedTagAssignmentServiceServer) GetOne(context.Context, *TagAssignmentRequest) (*TagAssignmentResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetOne not implemented")
}
func (UnimplementedTagAssignmentServiceServer) GetAll(*TagAssignmentStreamRequest, TagAssignmentService_GetAllServer) error {
	return status.Errorf(codes.Unimplemented, "method GetAll not implemented")
}
func (UnimplementedTagAssignmentServiceServer) Subscribe(*TagAssignmentStreamRequest, TagAssignmentService_SubscribeServer) error {
	return status.Errorf(codes.Unimplemented, "method Subscribe not implemented")
}
func (UnimplementedTagAssignmentServiceServer) mustEmbedUnimplementedTagAssignmentServiceServer() {}

// UnsafeTagAssignmentServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to TagAssignmentServiceServer will
// result in compilation errors.
type UnsafeTagAssignmentServiceServer interface {
	mustEmbedUnimplementedTagAssignmentServiceServer()
}

func RegisterTagAssignmentServiceServer(s grpc.ServiceRegistrar, srv TagAssignmentServiceServer) {
	s.RegisterService(&TagAssignmentService_ServiceDesc, srv)
}

func _TagAssignmentService_GetOne_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TagAssignmentRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TagAssignmentServiceServer).GetOne(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/arista.tag.v2.TagAssignmentService/GetOne",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TagAssignmentServiceServer).GetOne(ctx, req.(*TagAssignmentRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TagAssignmentService_GetAll_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(TagAssignmentStreamRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(TagAssignmentServiceServer).GetAll(m, &tagAssignmentServiceGetAllServer{stream})
}

type TagAssignmentService_GetAllServer interface {
	Send(*TagAssignmentStreamResponse) error
	grpc.ServerStream
}

type tagAssignmentServiceGetAllServer struct {
	grpc.ServerStream
}

func (x *tagAssignmentServiceGetAllServer) Send(m *TagAssignmentStreamResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _TagAssignmentService_Subscribe_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(TagAssignmentStreamRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(TagAssignmentServiceServer).Subscribe(m, &tagAssignmentServiceSubscribeServer{stream})
}

type TagAssignmentService_SubscribeServer interface {
	Send(*TagAssignmentStreamResponse) error
	grpc.ServerStream
}

type tagAssignmentServiceSubscribeServer struct {
	grpc.ServerStream
}

func (x *tagAssignmentServiceSubscribeServer) Send(m *TagAssignmentStreamResponse) error {
	return x.ServerStream.SendMsg(m)
}

// TagAssignmentService_ServiceDesc is the grpc.ServiceDesc for TagAssignmentService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var TagAssignmentService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "arista.tag.v2.TagAssignmentService",
	HandlerType: (*TagAssignmentServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetOne",
			Handler:    _TagAssignmentService_GetOne_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "GetAll",
			Handler:       _TagAssignmentService_GetAll_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "Subscribe",
			Handler:       _TagAssignmentService_Subscribe_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "arista/tag.v2/services.gen.proto",
}

// TagAssignmentConfigServiceClient is the client API for TagAssignmentConfigService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type TagAssignmentConfigServiceClient interface {
	GetOne(ctx context.Context, in *TagAssignmentConfigRequest, opts ...grpc.CallOption) (*TagAssignmentConfigResponse, error)
	GetAll(ctx context.Context, in *TagAssignmentConfigStreamRequest, opts ...grpc.CallOption) (TagAssignmentConfigService_GetAllClient, error)
	Subscribe(ctx context.Context, in *TagAssignmentConfigStreamRequest, opts ...grpc.CallOption) (TagAssignmentConfigService_SubscribeClient, error)
	Set(ctx context.Context, in *TagAssignmentConfigSetRequest, opts ...grpc.CallOption) (*TagAssignmentConfigSetResponse, error)
	Delete(ctx context.Context, in *TagAssignmentConfigDeleteRequest, opts ...grpc.CallOption) (*TagAssignmentConfigDeleteResponse, error)
}

type tagAssignmentConfigServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewTagAssignmentConfigServiceClient(cc grpc.ClientConnInterface) TagAssignmentConfigServiceClient {
	return &tagAssignmentConfigServiceClient{cc}
}

func (c *tagAssignmentConfigServiceClient) GetOne(ctx context.Context, in *TagAssignmentConfigRequest, opts ...grpc.CallOption) (*TagAssignmentConfigResponse, error) {
	out := new(TagAssignmentConfigResponse)
	err := c.cc.Invoke(ctx, "/arista.tag.v2.TagAssignmentConfigService/GetOne", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tagAssignmentConfigServiceClient) GetAll(ctx context.Context, in *TagAssignmentConfigStreamRequest, opts ...grpc.CallOption) (TagAssignmentConfigService_GetAllClient, error) {
	stream, err := c.cc.NewStream(ctx, &TagAssignmentConfigService_ServiceDesc.Streams[0], "/arista.tag.v2.TagAssignmentConfigService/GetAll", opts...)
	if err != nil {
		return nil, err
	}
	x := &tagAssignmentConfigServiceGetAllClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type TagAssignmentConfigService_GetAllClient interface {
	Recv() (*TagAssignmentConfigStreamResponse, error)
	grpc.ClientStream
}

type tagAssignmentConfigServiceGetAllClient struct {
	grpc.ClientStream
}

func (x *tagAssignmentConfigServiceGetAllClient) Recv() (*TagAssignmentConfigStreamResponse, error) {
	m := new(TagAssignmentConfigStreamResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *tagAssignmentConfigServiceClient) Subscribe(ctx context.Context, in *TagAssignmentConfigStreamRequest, opts ...grpc.CallOption) (TagAssignmentConfigService_SubscribeClient, error) {
	stream, err := c.cc.NewStream(ctx, &TagAssignmentConfigService_ServiceDesc.Streams[1], "/arista.tag.v2.TagAssignmentConfigService/Subscribe", opts...)
	if err != nil {
		return nil, err
	}
	x := &tagAssignmentConfigServiceSubscribeClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type TagAssignmentConfigService_SubscribeClient interface {
	Recv() (*TagAssignmentConfigStreamResponse, error)
	grpc.ClientStream
}

type tagAssignmentConfigServiceSubscribeClient struct {
	grpc.ClientStream
}

func (x *tagAssignmentConfigServiceSubscribeClient) Recv() (*TagAssignmentConfigStreamResponse, error) {
	m := new(TagAssignmentConfigStreamResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *tagAssignmentConfigServiceClient) Set(ctx context.Context, in *TagAssignmentConfigSetRequest, opts ...grpc.CallOption) (*TagAssignmentConfigSetResponse, error) {
	out := new(TagAssignmentConfigSetResponse)
	err := c.cc.Invoke(ctx, "/arista.tag.v2.TagAssignmentConfigService/Set", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tagAssignmentConfigServiceClient) Delete(ctx context.Context, in *TagAssignmentConfigDeleteRequest, opts ...grpc.CallOption) (*TagAssignmentConfigDeleteResponse, error) {
	out := new(TagAssignmentConfigDeleteResponse)
	err := c.cc.Invoke(ctx, "/arista.tag.v2.TagAssignmentConfigService/Delete", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// TagAssignmentConfigServiceServer is the server API for TagAssignmentConfigService service.
// All implementations must embed UnimplementedTagAssignmentConfigServiceServer
// for forward compatibility
type TagAssignmentConfigServiceServer interface {
	GetOne(context.Context, *TagAssignmentConfigRequest) (*TagAssignmentConfigResponse, error)
	GetAll(*TagAssignmentConfigStreamRequest, TagAssignmentConfigService_GetAllServer) error
	Subscribe(*TagAssignmentConfigStreamRequest, TagAssignmentConfigService_SubscribeServer) error
	Set(context.Context, *TagAssignmentConfigSetRequest) (*TagAssignmentConfigSetResponse, error)
	Delete(context.Context, *TagAssignmentConfigDeleteRequest) (*TagAssignmentConfigDeleteResponse, error)
	mustEmbedUnimplementedTagAssignmentConfigServiceServer()
}

// UnimplementedTagAssignmentConfigServiceServer must be embedded to have forward compatible implementations.
type UnimplementedTagAssignmentConfigServiceServer struct {
}

func (UnimplementedTagAssignmentConfigServiceServer) GetOne(context.Context, *TagAssignmentConfigRequest) (*TagAssignmentConfigResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetOne not implemented")
}
func (UnimplementedTagAssignmentConfigServiceServer) GetAll(*TagAssignmentConfigStreamRequest, TagAssignmentConfigService_GetAllServer) error {
	return status.Errorf(codes.Unimplemented, "method GetAll not implemented")
}
func (UnimplementedTagAssignmentConfigServiceServer) Subscribe(*TagAssignmentConfigStreamRequest, TagAssignmentConfigService_SubscribeServer) error {
	return status.Errorf(codes.Unimplemented, "method Subscribe not implemented")
}
func (UnimplementedTagAssignmentConfigServiceServer) Set(context.Context, *TagAssignmentConfigSetRequest) (*TagAssignmentConfigSetResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Set not implemented")
}
func (UnimplementedTagAssignmentConfigServiceServer) Delete(context.Context, *TagAssignmentConfigDeleteRequest) (*TagAssignmentConfigDeleteResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Delete not implemented")
}
func (UnimplementedTagAssignmentConfigServiceServer) mustEmbedUnimplementedTagAssignmentConfigServiceServer() {
}

// UnsafeTagAssignmentConfigServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to TagAssignmentConfigServiceServer will
// result in compilation errors.
type UnsafeTagAssignmentConfigServiceServer interface {
	mustEmbedUnimplementedTagAssignmentConfigServiceServer()
}

func RegisterTagAssignmentConfigServiceServer(s grpc.ServiceRegistrar, srv TagAssignmentConfigServiceServer) {
	s.RegisterService(&TagAssignmentConfigService_ServiceDesc, srv)
}

func _TagAssignmentConfigService_GetOne_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TagAssignmentConfigRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TagAssignmentConfigServiceServer).GetOne(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/arista.tag.v2.TagAssignmentConfigService/GetOne",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TagAssignmentConfigServiceServer).GetOne(ctx, req.(*TagAssignmentConfigRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TagAssignmentConfigService_GetAll_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(TagAssignmentConfigStreamRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(TagAssignmentConfigServiceServer).GetAll(m, &tagAssignmentConfigServiceGetAllServer{stream})
}

type TagAssignmentConfigService_GetAllServer interface {
	Send(*TagAssignmentConfigStreamResponse) error
	grpc.ServerStream
}

type tagAssignmentConfigServiceGetAllServer struct {
	grpc.ServerStream
}

func (x *tagAssignmentConfigServiceGetAllServer) Send(m *TagAssignmentConfigStreamResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _TagAssignmentConfigService_Subscribe_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(TagAssignmentConfigStreamRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(TagAssignmentConfigServiceServer).Subscribe(m, &tagAssignmentConfigServiceSubscribeServer{stream})
}

type TagAssignmentConfigService_SubscribeServer interface {
	Send(*TagAssignmentConfigStreamResponse) error
	grpc.ServerStream
}

type tagAssignmentConfigServiceSubscribeServer struct {
	grpc.ServerStream
}

func (x *tagAssignmentConfigServiceSubscribeServer) Send(m *TagAssignmentConfigStreamResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _TagAssignmentConfigService_Set_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TagAssignmentConfigSetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TagAssignmentConfigServiceServer).Set(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/arista.tag.v2.TagAssignmentConfigService/Set",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TagAssignmentConfigServiceServer).Set(ctx, req.(*TagAssignmentConfigSetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TagAssignmentConfigService_Delete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TagAssignmentConfigDeleteRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TagAssignmentConfigServiceServer).Delete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/arista.tag.v2.TagAssignmentConfigService/Delete",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TagAssignmentConfigServiceServer).Delete(ctx, req.(*TagAssignmentConfigDeleteRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// TagAssignmentConfigService_ServiceDesc is the grpc.ServiceDesc for TagAssignmentConfigService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var TagAssignmentConfigService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "arista.tag.v2.TagAssignmentConfigService",
	HandlerType: (*TagAssignmentConfigServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetOne",
			Handler:    _TagAssignmentConfigService_GetOne_Handler,
		},
		{
			MethodName: "Set",
			Handler:    _TagAssignmentConfigService_Set_Handler,
		},
		{
			MethodName: "Delete",
			Handler:    _TagAssignmentConfigService_Delete_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "GetAll",
			Handler:       _TagAssignmentConfigService_GetAll_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "Subscribe",
			Handler:       _TagAssignmentConfigService_Subscribe_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "arista/tag.v2/services.gen.proto",
}

// TagConfigServiceClient is the client API for TagConfigService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type TagConfigServiceClient interface {
	GetOne(ctx context.Context, in *TagConfigRequest, opts ...grpc.CallOption) (*TagConfigResponse, error)
	GetAll(ctx context.Context, in *TagConfigStreamRequest, opts ...grpc.CallOption) (TagConfigService_GetAllClient, error)
	Subscribe(ctx context.Context, in *TagConfigStreamRequest, opts ...grpc.CallOption) (TagConfigService_SubscribeClient, error)
	Set(ctx context.Context, in *TagConfigSetRequest, opts ...grpc.CallOption) (*TagConfigSetResponse, error)
	Delete(ctx context.Context, in *TagConfigDeleteRequest, opts ...grpc.CallOption) (*TagConfigDeleteResponse, error)
}

type tagConfigServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewTagConfigServiceClient(cc grpc.ClientConnInterface) TagConfigServiceClient {
	return &tagConfigServiceClient{cc}
}

func (c *tagConfigServiceClient) GetOne(ctx context.Context, in *TagConfigRequest, opts ...grpc.CallOption) (*TagConfigResponse, error) {
	out := new(TagConfigResponse)
	err := c.cc.Invoke(ctx, "/arista.tag.v2.TagConfigService/GetOne", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tagConfigServiceClient) GetAll(ctx context.Context, in *TagConfigStreamRequest, opts ...grpc.CallOption) (TagConfigService_GetAllClient, error) {
	stream, err := c.cc.NewStream(ctx, &TagConfigService_ServiceDesc.Streams[0], "/arista.tag.v2.TagConfigService/GetAll", opts...)
	if err != nil {
		return nil, err
	}
	x := &tagConfigServiceGetAllClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type TagConfigService_GetAllClient interface {
	Recv() (*TagConfigStreamResponse, error)
	grpc.ClientStream
}

type tagConfigServiceGetAllClient struct {
	grpc.ClientStream
}

func (x *tagConfigServiceGetAllClient) Recv() (*TagConfigStreamResponse, error) {
	m := new(TagConfigStreamResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *tagConfigServiceClient) Subscribe(ctx context.Context, in *TagConfigStreamRequest, opts ...grpc.CallOption) (TagConfigService_SubscribeClient, error) {
	stream, err := c.cc.NewStream(ctx, &TagConfigService_ServiceDesc.Streams[1], "/arista.tag.v2.TagConfigService/Subscribe", opts...)
	if err != nil {
		return nil, err
	}
	x := &tagConfigServiceSubscribeClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type TagConfigService_SubscribeClient interface {
	Recv() (*TagConfigStreamResponse, error)
	grpc.ClientStream
}

type tagConfigServiceSubscribeClient struct {
	grpc.ClientStream
}

func (x *tagConfigServiceSubscribeClient) Recv() (*TagConfigStreamResponse, error) {
	m := new(TagConfigStreamResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *tagConfigServiceClient) Set(ctx context.Context, in *TagConfigSetRequest, opts ...grpc.CallOption) (*TagConfigSetResponse, error) {
	out := new(TagConfigSetResponse)
	err := c.cc.Invoke(ctx, "/arista.tag.v2.TagConfigService/Set", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tagConfigServiceClient) Delete(ctx context.Context, in *TagConfigDeleteRequest, opts ...grpc.CallOption) (*TagConfigDeleteResponse, error) {
	out := new(TagConfigDeleteResponse)
	err := c.cc.Invoke(ctx, "/arista.tag.v2.TagConfigService/Delete", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// TagConfigServiceServer is the server API for TagConfigService service.
// All implementations must embed UnimplementedTagConfigServiceServer
// for forward compatibility
type TagConfigServiceServer interface {
	GetOne(context.Context, *TagConfigRequest) (*TagConfigResponse, error)
	GetAll(*TagConfigStreamRequest, TagConfigService_GetAllServer) error
	Subscribe(*TagConfigStreamRequest, TagConfigService_SubscribeServer) error
	Set(context.Context, *TagConfigSetRequest) (*TagConfigSetResponse, error)
	Delete(context.Context, *TagConfigDeleteRequest) (*TagConfigDeleteResponse, error)
	mustEmbedUnimplementedTagConfigServiceServer()
}

// UnimplementedTagConfigServiceServer must be embedded to have forward compatible implementations.
type UnimplementedTagConfigServiceServer struct {
}

func (UnimplementedTagConfigServiceServer) GetOne(context.Context, *TagConfigRequest) (*TagConfigResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetOne not implemented")
}
func (UnimplementedTagConfigServiceServer) GetAll(*TagConfigStreamRequest, TagConfigService_GetAllServer) error {
	return status.Errorf(codes.Unimplemented, "method GetAll not implemented")
}
func (UnimplementedTagConfigServiceServer) Subscribe(*TagConfigStreamRequest, TagConfigService_SubscribeServer) error {
	return status.Errorf(codes.Unimplemented, "method Subscribe not implemented")
}
func (UnimplementedTagConfigServiceServer) Set(context.Context, *TagConfigSetRequest) (*TagConfigSetResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Set not implemented")
}
func (UnimplementedTagConfigServiceServer) Delete(context.Context, *TagConfigDeleteRequest) (*TagConfigDeleteResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Delete not implemented")
}
func (UnimplementedTagConfigServiceServer) mustEmbedUnimplementedTagConfigServiceServer() {}

// UnsafeTagConfigServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to TagConfigServiceServer will
// result in compilation errors.
type UnsafeTagConfigServiceServer interface {
	mustEmbedUnimplementedTagConfigServiceServer()
}

func RegisterTagConfigServiceServer(s grpc.ServiceRegistrar, srv TagConfigServiceServer) {
	s.RegisterService(&TagConfigService_ServiceDesc, srv)
}

func _TagConfigService_GetOne_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TagConfigRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TagConfigServiceServer).GetOne(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/arista.tag.v2.TagConfigService/GetOne",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TagConfigServiceServer).GetOne(ctx, req.(*TagConfigRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TagConfigService_GetAll_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(TagConfigStreamRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(TagConfigServiceServer).GetAll(m, &tagConfigServiceGetAllServer{stream})
}

type TagConfigService_GetAllServer interface {
	Send(*TagConfigStreamResponse) error
	grpc.ServerStream
}

type tagConfigServiceGetAllServer struct {
	grpc.ServerStream
}

func (x *tagConfigServiceGetAllServer) Send(m *TagConfigStreamResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _TagConfigService_Subscribe_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(TagConfigStreamRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(TagConfigServiceServer).Subscribe(m, &tagConfigServiceSubscribeServer{stream})
}

type TagConfigService_SubscribeServer interface {
	Send(*TagConfigStreamResponse) error
	grpc.ServerStream
}

type tagConfigServiceSubscribeServer struct {
	grpc.ServerStream
}

func (x *tagConfigServiceSubscribeServer) Send(m *TagConfigStreamResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _TagConfigService_Set_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TagConfigSetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TagConfigServiceServer).Set(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/arista.tag.v2.TagConfigService/Set",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TagConfigServiceServer).Set(ctx, req.(*TagConfigSetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TagConfigService_Delete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TagConfigDeleteRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TagConfigServiceServer).Delete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/arista.tag.v2.TagConfigService/Delete",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TagConfigServiceServer).Delete(ctx, req.(*TagConfigDeleteRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// TagConfigService_ServiceDesc is the grpc.ServiceDesc for TagConfigService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var TagConfigService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "arista.tag.v2.TagConfigService",
	HandlerType: (*TagConfigServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetOne",
			Handler:    _TagConfigService_GetOne_Handler,
		},
		{
			MethodName: "Set",
			Handler:    _TagConfigService_Set_Handler,
		},
		{
			MethodName: "Delete",
			Handler:    _TagConfigService_Delete_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "GetAll",
			Handler:       _TagConfigService_GetAll_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "Subscribe",
			Handler:       _TagConfigService_Subscribe_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "arista/tag.v2/services.gen.proto",
}
