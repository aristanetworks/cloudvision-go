// Copyright (c) 2024 Arista Networks, Inc.  All rights reserved.
// Use of this source code is governed by the Apache License 2.0
// that can be found in the COPYING file.

//
// Code generated by boomtown. DO NOT EDIT.
//

package tag

import "google.golang.org/grpc"

// Client composes the service clients within the tag package.
// This client can then be composed into a larger hierarchy for more complex clients.
//
// Because method names include the name of the Resource they operate on, the embedded
// clients are unnamed fields to reduce stutter.
//
// Included resources:
//   - Tag
//   - TagAssignment
//   - TagAssignmentConfig
//   - TagConfig
type Client struct {
	Tag                 TagServiceClient
	TagAssignment       TagAssignmentServiceClient
	TagAssignmentConfig TagAssignmentConfigServiceClient
	TagConfig           TagConfigServiceClient
}

// NewClient creates a new composed-client from the given connection.
func NewClient(conn grpc.ClientConnInterface) Client {
	return Client{
		Tag:                 NewTagServiceClient(conn),
		TagAssignment:       NewTagAssignmentServiceClient(conn),
		TagAssignmentConfig: NewTagAssignmentConfigServiceClient(conn),
		TagConfig:           NewTagConfigServiceClient(conn),
	}
}

// Server aggregates the various server interfaces required by gRPC.
// The included resources are:
//   - Tag
//   - TagAssignment
//   - TagAssignmentConfig
//   - TagConfig
type Server struct {
	Tag                 TagServiceServer
	TagAssignment       TagAssignmentServiceServer
	TagAssignmentConfig TagAssignmentConfigServiceServer
	TagConfig           TagConfigServiceServer
}

// Register takes the given gRPC Server and registers our services with it.
func (s Server) Register(target *grpc.Server) {
	RegisterTagServiceServer(target, s.Tag)
	RegisterTagAssignmentServiceServer(target, s.TagAssignment)
	RegisterTagAssignmentConfigServiceServer(target, s.TagAssignmentConfig)
	RegisterTagConfigServiceServer(target, s.TagConfig)
}

// RegisterUnimplementeds adds unimplemented servers to the given gRPC Server
func RegisterUnimplementeds(target *grpc.Server) error {
	RegisterTagServiceServer(target,
		UnimplementedTagServiceServer{})
	RegisterTagAssignmentServiceServer(target,
		UnimplementedTagAssignmentServiceServer{})
	RegisterTagAssignmentConfigServiceServer(target,
		UnimplementedTagAssignmentConfigServiceServer{})
	RegisterTagConfigServiceServer(target,
		UnimplementedTagConfigServiceServer{})
	return nil
}

// HasKey returns whether the given Tag has a key provided in the model.
func (t *Tag) HasKey() bool {
	return t.GetKey() != nil
}

// HasKey returns whether the given TagRequest has a key provided in the request.
func (t *TagRequest) HasKey() bool {
	return t.GetKey() != nil
}

// HasKey returns whether the given TagAssignment has a key provided in the model.
func (t *TagAssignment) HasKey() bool {
	return t.GetKey() != nil
}

// HasKey returns whether the given TagAssignmentRequest has a key provided in the request.
func (t *TagAssignmentRequest) HasKey() bool {
	return t.GetKey() != nil
}

// HasKey returns whether the given TagAssignmentConfig has a key provided in the model.
func (t *TagAssignmentConfig) HasKey() bool {
	return t.GetKey() != nil
}

// HasKey returns whether the given TagAssignmentConfigRequest has a key provided in the request.
func (t *TagAssignmentConfigRequest) HasKey() bool {
	return t.GetKey() != nil
}

// HasKey returns whether the given TagAssignmentConfigSetRequest has a key provided in the request.
func (t *TagAssignmentConfigSetRequest) HasKey() bool {
	return t.GetValue().HasKey()
}

// HasKey returns whether the given TagAssignmentConfigDeleteRequest has a key provided in the request.
func (t *TagAssignmentConfigDeleteRequest) HasKey() bool {
	return t.GetKey() != nil
}

// HasKey returns whether the given TagConfig has a key provided in the model.
func (t *TagConfig) HasKey() bool {
	return t.GetKey() != nil
}

// HasKey returns whether the given TagConfigRequest has a key provided in the request.
func (t *TagConfigRequest) HasKey() bool {
	return t.GetKey() != nil
}

// HasKey returns whether the given TagConfigSetRequest has a key provided in the request.
func (t *TagConfigSetRequest) HasKey() bool {
	return t.GetValue().HasKey()
}

// HasKey returns whether the given TagConfigDeleteRequest has a key provided in the request.
func (t *TagConfigDeleteRequest) HasKey() bool {
	return t.GetKey() != nil
}

// PassesPartialEqFilter returns whether this CreatorType matches the comparison. If the given
// argument is unitialized, it is considered a match.
func (c CreatorType) PassesPartialEqFilter(cmp CreatorType) bool {
	if cmp != CreatorType(0) {
		return c == cmp
	}
	return true
}

// PassesPartialEqFilter returns whether this ElementSubType matches the comparison. If the given
// argument is unitialized, it is considered a match.
func (e ElementSubType) PassesPartialEqFilter(cmp ElementSubType) bool {
	if cmp != ElementSubType(0) {
		return e == cmp
	}
	return true
}

// PassesPartialEqFilter returns whether this ElementType matches the comparison. If the given
// argument is unitialized, it is considered a match.
func (e ElementType) PassesPartialEqFilter(cmp ElementType) bool {
	if cmp != ElementType(0) {
		return e == cmp
	}
	return true
}

// PassesPartialEqFilter returns whether the TagAssignmentKey matches the passed in filter.
// On a nil comparison, we consider it a pass. Otherwise, all set (non-nil, initialized)
// fields are expected to match their "sibling" field in the comparison. Any non-matching
// value is considered a mismatch of the filter.
func (t *TagAssignmentKey) PassesPartialEqFilter(cmp *TagAssignmentKey) bool {
	// gave nothing to filter on, consider it passing
	if cmp == nil {
		return true
	}

	if t == nil {
		return false
	}

	if cmp.WorkspaceId != nil {
		if t.WorkspaceId == nil {
			return false
		}
		if t.WorkspaceId.Value != cmp.WorkspaceId.Value {
			return false
		}
	}
	if !t.ElementType.PassesPartialEqFilter(cmp.ElementType) {
		return false
	}

	if cmp.Label != nil {
		if t.Label == nil {
			return false
		}
		if t.Label.Value != cmp.Label.Value {
			return false
		}
	}

	if cmp.Value != nil {
		if t.Value == nil {
			return false
		}
		if t.Value.Value != cmp.Value.Value {
			return false
		}
	}

	if cmp.DeviceId != nil {
		if t.DeviceId == nil {
			return false
		}
		if t.DeviceId.Value != cmp.DeviceId.Value {
			return false
		}
	}

	if cmp.InterfaceId != nil {
		if t.InterfaceId == nil {
			return false
		}
		if t.InterfaceId.Value != cmp.InterfaceId.Value {
			return false
		}
	}
	if !t.ElementSubType.PassesPartialEqFilter(cmp.ElementSubType) {
		return false
	}

	return true
}

// PassesPartialEqFilter returns whether the TagKey matches the passed in filter.
// On a nil comparison, we consider it a pass. Otherwise, all set (non-nil, initialized)
// fields are expected to match their "sibling" field in the comparison. Any non-matching
// value is considered a mismatch of the filter.
func (t *TagKey) PassesPartialEqFilter(cmp *TagKey) bool {
	// gave nothing to filter on, consider it passing
	if cmp == nil {
		return true
	}

	if t == nil {
		return false
	}

	if cmp.WorkspaceId != nil {
		if t.WorkspaceId == nil {
			return false
		}
		if t.WorkspaceId.Value != cmp.WorkspaceId.Value {
			return false
		}
	}
	if !t.ElementType.PassesPartialEqFilter(cmp.ElementType) {
		return false
	}

	if cmp.Label != nil {
		if t.Label == nil {
			return false
		}
		if t.Label.Value != cmp.Label.Value {
			return false
		}
	}

	if cmp.Value != nil {
		if t.Value == nil {
			return false
		}
		if t.Value.Value != cmp.Value.Value {
			return false
		}
	}
	if !t.ElementSubType.PassesPartialEqFilter(cmp.ElementSubType) {
		return false
	}

	return true
}

// PassesPartialEqFilter returns whether the Tag matches the passed in filter.
// On a nil comparison, we consider it a pass. Otherwise, all set (non-nil, initialized)
// fields are expected to match their "sibling" field in the comparison. Any non-matching
// value is considered a mismatch of the filter.
func (t *Tag) PassesPartialEqFilter(cmp *Tag) bool {
	// if the resource is nil, there is nothing to send to the client
	if t == nil {
		return false
	}

	// gave nothing to filter on, consider it passing
	if cmp == nil {
		return true
	}

	if !t.Key.PassesPartialEqFilter(cmp.Key) {
		return false
	}

	if !t.CreatorType.PassesPartialEqFilter(cmp.CreatorType) {
		return false
	}

	return true
}

// MatchesAnyPartialEqFilter returns whether the receiver matches any filters in the given set.
func (t *Tag) MatchesAnyPartialEqFilter(filters []*Tag) bool {
	if len(filters) == 0 {
		return true
	}

	for _, filt := range filters {
		if t.PassesPartialEqFilter(filt) {
			return true
		}
	}

	return false
}

// PassesPartialEqFilter returns whether the TagAssignment matches the passed in filter.
// On a nil comparison, we consider it a pass. Otherwise, all set (non-nil, initialized)
// fields are expected to match their "sibling" field in the comparison. Any non-matching
// value is considered a mismatch of the filter.
func (t *TagAssignment) PassesPartialEqFilter(cmp *TagAssignment) bool {
	// if the resource is nil, there is nothing to send to the client
	if t == nil {
		return false
	}

	// gave nothing to filter on, consider it passing
	if cmp == nil {
		return true
	}

	if !t.Key.PassesPartialEqFilter(cmp.Key) {
		return false
	}

	if !t.TagCreatorType.PassesPartialEqFilter(cmp.TagCreatorType) {
		return false
	}

	return true
}

// MatchesAnyPartialEqFilter returns whether the receiver matches any filters in the given set.
func (t *TagAssignment) MatchesAnyPartialEqFilter(filters []*TagAssignment) bool {
	if len(filters) == 0 {
		return true
	}

	for _, filt := range filters {
		if t.PassesPartialEqFilter(filt) {
			return true
		}
	}

	return false
}

// PassesPartialEqFilter returns whether the TagAssignmentConfig matches the passed in filter.
// On a nil comparison, we consider it a pass. Otherwise, all set (non-nil, initialized)
// fields are expected to match their "sibling" field in the comparison. Any non-matching
// value is considered a mismatch of the filter.
func (t *TagAssignmentConfig) PassesPartialEqFilter(cmp *TagAssignmentConfig) bool {
	// if the resource is nil, there is nothing to send to the client
	if t == nil {
		return false
	}

	// gave nothing to filter on, consider it passing
	if cmp == nil {
		return true
	}

	if !t.Key.PassesPartialEqFilter(cmp.Key) {
		return false
	}

	if cmp.Remove != nil {
		if t.Remove == nil {
			return false
		}
		if t.Remove.Value != cmp.Remove.Value {
			return false
		}
	}

	return true
}

// MatchesAnyPartialEqFilter returns whether the receiver matches any filters in the given set.
func (t *TagAssignmentConfig) MatchesAnyPartialEqFilter(filters []*TagAssignmentConfig) bool {
	if len(filters) == 0 {
		return true
	}

	for _, filt := range filters {
		if t.PassesPartialEqFilter(filt) {
			return true
		}
	}

	return false
}

// PassesPartialEqFilter returns whether the TagConfig matches the passed in filter.
// On a nil comparison, we consider it a pass. Otherwise, all set (non-nil, initialized)
// fields are expected to match their "sibling" field in the comparison. Any non-matching
// value is considered a mismatch of the filter.
func (t *TagConfig) PassesPartialEqFilter(cmp *TagConfig) bool {
	// if the resource is nil, there is nothing to send to the client
	if t == nil {
		return false
	}

	// gave nothing to filter on, consider it passing
	if cmp == nil {
		return true
	}

	if !t.Key.PassesPartialEqFilter(cmp.Key) {
		return false
	}

	if cmp.Remove != nil {
		if t.Remove == nil {
			return false
		}
		if t.Remove.Value != cmp.Remove.Value {
			return false
		}
	}

	return true
}

// MatchesAnyPartialEqFilter returns whether the receiver matches any filters in the given set.
func (t *TagConfig) MatchesAnyPartialEqFilter(filters []*TagConfig) bool {
	if len(filters) == 0 {
		return true
	}

	for _, filt := range filters {
		if t.PassesPartialEqFilter(filt) {
			return true
		}
	}

	return false
}
