// Code generated by protoc-gen-go-grpc. DO NOT EDIT.

package studio

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

// AssignedTagsServiceClient is the client API for AssignedTagsService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type AssignedTagsServiceClient interface {
	GetOne(ctx context.Context, in *AssignedTagsRequest, opts ...grpc.CallOption) (*AssignedTagsResponse, error)
	GetAll(ctx context.Context, in *AssignedTagsStreamRequest, opts ...grpc.CallOption) (AssignedTagsService_GetAllClient, error)
	Subscribe(ctx context.Context, in *AssignedTagsStreamRequest, opts ...grpc.CallOption) (AssignedTagsService_SubscribeClient, error)
}

type assignedTagsServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewAssignedTagsServiceClient(cc grpc.ClientConnInterface) AssignedTagsServiceClient {
	return &assignedTagsServiceClient{cc}
}

func (c *assignedTagsServiceClient) GetOne(ctx context.Context, in *AssignedTagsRequest, opts ...grpc.CallOption) (*AssignedTagsResponse, error) {
	out := new(AssignedTagsResponse)
	err := c.cc.Invoke(ctx, "/arista.studio.v1.AssignedTagsService/GetOne", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *assignedTagsServiceClient) GetAll(ctx context.Context, in *AssignedTagsStreamRequest, opts ...grpc.CallOption) (AssignedTagsService_GetAllClient, error) {
	stream, err := c.cc.NewStream(ctx, &AssignedTagsService_ServiceDesc.Streams[0], "/arista.studio.v1.AssignedTagsService/GetAll", opts...)
	if err != nil {
		return nil, err
	}
	x := &assignedTagsServiceGetAllClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type AssignedTagsService_GetAllClient interface {
	Recv() (*AssignedTagsStreamResponse, error)
	grpc.ClientStream
}

type assignedTagsServiceGetAllClient struct {
	grpc.ClientStream
}

func (x *assignedTagsServiceGetAllClient) Recv() (*AssignedTagsStreamResponse, error) {
	m := new(AssignedTagsStreamResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *assignedTagsServiceClient) Subscribe(ctx context.Context, in *AssignedTagsStreamRequest, opts ...grpc.CallOption) (AssignedTagsService_SubscribeClient, error) {
	stream, err := c.cc.NewStream(ctx, &AssignedTagsService_ServiceDesc.Streams[1], "/arista.studio.v1.AssignedTagsService/Subscribe", opts...)
	if err != nil {
		return nil, err
	}
	x := &assignedTagsServiceSubscribeClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type AssignedTagsService_SubscribeClient interface {
	Recv() (*AssignedTagsStreamResponse, error)
	grpc.ClientStream
}

type assignedTagsServiceSubscribeClient struct {
	grpc.ClientStream
}

func (x *assignedTagsServiceSubscribeClient) Recv() (*AssignedTagsStreamResponse, error) {
	m := new(AssignedTagsStreamResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// AssignedTagsServiceServer is the server API for AssignedTagsService service.
// All implementations must embed UnimplementedAssignedTagsServiceServer
// for forward compatibility
type AssignedTagsServiceServer interface {
	GetOne(context.Context, *AssignedTagsRequest) (*AssignedTagsResponse, error)
	GetAll(*AssignedTagsStreamRequest, AssignedTagsService_GetAllServer) error
	Subscribe(*AssignedTagsStreamRequest, AssignedTagsService_SubscribeServer) error
	mustEmbedUnimplementedAssignedTagsServiceServer()
}

// UnimplementedAssignedTagsServiceServer must be embedded to have forward compatible implementations.
type UnimplementedAssignedTagsServiceServer struct {
}

func (UnimplementedAssignedTagsServiceServer) GetOne(context.Context, *AssignedTagsRequest) (*AssignedTagsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetOne not implemented")
}
func (UnimplementedAssignedTagsServiceServer) GetAll(*AssignedTagsStreamRequest, AssignedTagsService_GetAllServer) error {
	return status.Errorf(codes.Unimplemented, "method GetAll not implemented")
}
func (UnimplementedAssignedTagsServiceServer) Subscribe(*AssignedTagsStreamRequest, AssignedTagsService_SubscribeServer) error {
	return status.Errorf(codes.Unimplemented, "method Subscribe not implemented")
}
func (UnimplementedAssignedTagsServiceServer) mustEmbedUnimplementedAssignedTagsServiceServer() {}

// UnsafeAssignedTagsServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to AssignedTagsServiceServer will
// result in compilation errors.
type UnsafeAssignedTagsServiceServer interface {
	mustEmbedUnimplementedAssignedTagsServiceServer()
}

func RegisterAssignedTagsServiceServer(s grpc.ServiceRegistrar, srv AssignedTagsServiceServer) {
	s.RegisterService(&AssignedTagsService_ServiceDesc, srv)
}

func _AssignedTagsService_GetOne_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AssignedTagsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AssignedTagsServiceServer).GetOne(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/arista.studio.v1.AssignedTagsService/GetOne",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AssignedTagsServiceServer).GetOne(ctx, req.(*AssignedTagsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AssignedTagsService_GetAll_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(AssignedTagsStreamRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(AssignedTagsServiceServer).GetAll(m, &assignedTagsServiceGetAllServer{stream})
}

type AssignedTagsService_GetAllServer interface {
	Send(*AssignedTagsStreamResponse) error
	grpc.ServerStream
}

type assignedTagsServiceGetAllServer struct {
	grpc.ServerStream
}

func (x *assignedTagsServiceGetAllServer) Send(m *AssignedTagsStreamResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _AssignedTagsService_Subscribe_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(AssignedTagsStreamRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(AssignedTagsServiceServer).Subscribe(m, &assignedTagsServiceSubscribeServer{stream})
}

type AssignedTagsService_SubscribeServer interface {
	Send(*AssignedTagsStreamResponse) error
	grpc.ServerStream
}

type assignedTagsServiceSubscribeServer struct {
	grpc.ServerStream
}

func (x *assignedTagsServiceSubscribeServer) Send(m *AssignedTagsStreamResponse) error {
	return x.ServerStream.SendMsg(m)
}

// AssignedTagsService_ServiceDesc is the grpc.ServiceDesc for AssignedTagsService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var AssignedTagsService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "arista.studio.v1.AssignedTagsService",
	HandlerType: (*AssignedTagsServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetOne",
			Handler:    _AssignedTagsService_GetOne_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "GetAll",
			Handler:       _AssignedTagsService_GetAll_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "Subscribe",
			Handler:       _AssignedTagsService_Subscribe_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "arista/studio.v1/services.gen.proto",
}

// AssignedTagsConfigServiceClient is the client API for AssignedTagsConfigService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type AssignedTagsConfigServiceClient interface {
	GetOne(ctx context.Context, in *AssignedTagsConfigRequest, opts ...grpc.CallOption) (*AssignedTagsConfigResponse, error)
	GetAll(ctx context.Context, in *AssignedTagsConfigStreamRequest, opts ...grpc.CallOption) (AssignedTagsConfigService_GetAllClient, error)
	Subscribe(ctx context.Context, in *AssignedTagsConfigStreamRequest, opts ...grpc.CallOption) (AssignedTagsConfigService_SubscribeClient, error)
	Set(ctx context.Context, in *AssignedTagsConfigSetRequest, opts ...grpc.CallOption) (*AssignedTagsConfigSetResponse, error)
	Delete(ctx context.Context, in *AssignedTagsConfigDeleteRequest, opts ...grpc.CallOption) (*AssignedTagsConfigDeleteResponse, error)
}

type assignedTagsConfigServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewAssignedTagsConfigServiceClient(cc grpc.ClientConnInterface) AssignedTagsConfigServiceClient {
	return &assignedTagsConfigServiceClient{cc}
}

func (c *assignedTagsConfigServiceClient) GetOne(ctx context.Context, in *AssignedTagsConfigRequest, opts ...grpc.CallOption) (*AssignedTagsConfigResponse, error) {
	out := new(AssignedTagsConfigResponse)
	err := c.cc.Invoke(ctx, "/arista.studio.v1.AssignedTagsConfigService/GetOne", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *assignedTagsConfigServiceClient) GetAll(ctx context.Context, in *AssignedTagsConfigStreamRequest, opts ...grpc.CallOption) (AssignedTagsConfigService_GetAllClient, error) {
	stream, err := c.cc.NewStream(ctx, &AssignedTagsConfigService_ServiceDesc.Streams[0], "/arista.studio.v1.AssignedTagsConfigService/GetAll", opts...)
	if err != nil {
		return nil, err
	}
	x := &assignedTagsConfigServiceGetAllClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type AssignedTagsConfigService_GetAllClient interface {
	Recv() (*AssignedTagsConfigStreamResponse, error)
	grpc.ClientStream
}

type assignedTagsConfigServiceGetAllClient struct {
	grpc.ClientStream
}

func (x *assignedTagsConfigServiceGetAllClient) Recv() (*AssignedTagsConfigStreamResponse, error) {
	m := new(AssignedTagsConfigStreamResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *assignedTagsConfigServiceClient) Subscribe(ctx context.Context, in *AssignedTagsConfigStreamRequest, opts ...grpc.CallOption) (AssignedTagsConfigService_SubscribeClient, error) {
	stream, err := c.cc.NewStream(ctx, &AssignedTagsConfigService_ServiceDesc.Streams[1], "/arista.studio.v1.AssignedTagsConfigService/Subscribe", opts...)
	if err != nil {
		return nil, err
	}
	x := &assignedTagsConfigServiceSubscribeClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type AssignedTagsConfigService_SubscribeClient interface {
	Recv() (*AssignedTagsConfigStreamResponse, error)
	grpc.ClientStream
}

type assignedTagsConfigServiceSubscribeClient struct {
	grpc.ClientStream
}

func (x *assignedTagsConfigServiceSubscribeClient) Recv() (*AssignedTagsConfigStreamResponse, error) {
	m := new(AssignedTagsConfigStreamResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *assignedTagsConfigServiceClient) Set(ctx context.Context, in *AssignedTagsConfigSetRequest, opts ...grpc.CallOption) (*AssignedTagsConfigSetResponse, error) {
	out := new(AssignedTagsConfigSetResponse)
	err := c.cc.Invoke(ctx, "/arista.studio.v1.AssignedTagsConfigService/Set", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *assignedTagsConfigServiceClient) Delete(ctx context.Context, in *AssignedTagsConfigDeleteRequest, opts ...grpc.CallOption) (*AssignedTagsConfigDeleteResponse, error) {
	out := new(AssignedTagsConfigDeleteResponse)
	err := c.cc.Invoke(ctx, "/arista.studio.v1.AssignedTagsConfigService/Delete", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// AssignedTagsConfigServiceServer is the server API for AssignedTagsConfigService service.
// All implementations must embed UnimplementedAssignedTagsConfigServiceServer
// for forward compatibility
type AssignedTagsConfigServiceServer interface {
	GetOne(context.Context, *AssignedTagsConfigRequest) (*AssignedTagsConfigResponse, error)
	GetAll(*AssignedTagsConfigStreamRequest, AssignedTagsConfigService_GetAllServer) error
	Subscribe(*AssignedTagsConfigStreamRequest, AssignedTagsConfigService_SubscribeServer) error
	Set(context.Context, *AssignedTagsConfigSetRequest) (*AssignedTagsConfigSetResponse, error)
	Delete(context.Context, *AssignedTagsConfigDeleteRequest) (*AssignedTagsConfigDeleteResponse, error)
	mustEmbedUnimplementedAssignedTagsConfigServiceServer()
}

// UnimplementedAssignedTagsConfigServiceServer must be embedded to have forward compatible implementations.
type UnimplementedAssignedTagsConfigServiceServer struct {
}

func (UnimplementedAssignedTagsConfigServiceServer) GetOne(context.Context, *AssignedTagsConfigRequest) (*AssignedTagsConfigResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetOne not implemented")
}
func (UnimplementedAssignedTagsConfigServiceServer) GetAll(*AssignedTagsConfigStreamRequest, AssignedTagsConfigService_GetAllServer) error {
	return status.Errorf(codes.Unimplemented, "method GetAll not implemented")
}
func (UnimplementedAssignedTagsConfigServiceServer) Subscribe(*AssignedTagsConfigStreamRequest, AssignedTagsConfigService_SubscribeServer) error {
	return status.Errorf(codes.Unimplemented, "method Subscribe not implemented")
}
func (UnimplementedAssignedTagsConfigServiceServer) Set(context.Context, *AssignedTagsConfigSetRequest) (*AssignedTagsConfigSetResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Set not implemented")
}
func (UnimplementedAssignedTagsConfigServiceServer) Delete(context.Context, *AssignedTagsConfigDeleteRequest) (*AssignedTagsConfigDeleteResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Delete not implemented")
}
func (UnimplementedAssignedTagsConfigServiceServer) mustEmbedUnimplementedAssignedTagsConfigServiceServer() {
}

// UnsafeAssignedTagsConfigServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to AssignedTagsConfigServiceServer will
// result in compilation errors.
type UnsafeAssignedTagsConfigServiceServer interface {
	mustEmbedUnimplementedAssignedTagsConfigServiceServer()
}

func RegisterAssignedTagsConfigServiceServer(s grpc.ServiceRegistrar, srv AssignedTagsConfigServiceServer) {
	s.RegisterService(&AssignedTagsConfigService_ServiceDesc, srv)
}

func _AssignedTagsConfigService_GetOne_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AssignedTagsConfigRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AssignedTagsConfigServiceServer).GetOne(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/arista.studio.v1.AssignedTagsConfigService/GetOne",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AssignedTagsConfigServiceServer).GetOne(ctx, req.(*AssignedTagsConfigRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AssignedTagsConfigService_GetAll_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(AssignedTagsConfigStreamRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(AssignedTagsConfigServiceServer).GetAll(m, &assignedTagsConfigServiceGetAllServer{stream})
}

type AssignedTagsConfigService_GetAllServer interface {
	Send(*AssignedTagsConfigStreamResponse) error
	grpc.ServerStream
}

type assignedTagsConfigServiceGetAllServer struct {
	grpc.ServerStream
}

func (x *assignedTagsConfigServiceGetAllServer) Send(m *AssignedTagsConfigStreamResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _AssignedTagsConfigService_Subscribe_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(AssignedTagsConfigStreamRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(AssignedTagsConfigServiceServer).Subscribe(m, &assignedTagsConfigServiceSubscribeServer{stream})
}

type AssignedTagsConfigService_SubscribeServer interface {
	Send(*AssignedTagsConfigStreamResponse) error
	grpc.ServerStream
}

type assignedTagsConfigServiceSubscribeServer struct {
	grpc.ServerStream
}

func (x *assignedTagsConfigServiceSubscribeServer) Send(m *AssignedTagsConfigStreamResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _AssignedTagsConfigService_Set_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AssignedTagsConfigSetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AssignedTagsConfigServiceServer).Set(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/arista.studio.v1.AssignedTagsConfigService/Set",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AssignedTagsConfigServiceServer).Set(ctx, req.(*AssignedTagsConfigSetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AssignedTagsConfigService_Delete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AssignedTagsConfigDeleteRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AssignedTagsConfigServiceServer).Delete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/arista.studio.v1.AssignedTagsConfigService/Delete",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AssignedTagsConfigServiceServer).Delete(ctx, req.(*AssignedTagsConfigDeleteRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// AssignedTagsConfigService_ServiceDesc is the grpc.ServiceDesc for AssignedTagsConfigService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var AssignedTagsConfigService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "arista.studio.v1.AssignedTagsConfigService",
	HandlerType: (*AssignedTagsConfigServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetOne",
			Handler:    _AssignedTagsConfigService_GetOne_Handler,
		},
		{
			MethodName: "Set",
			Handler:    _AssignedTagsConfigService_Set_Handler,
		},
		{
			MethodName: "Delete",
			Handler:    _AssignedTagsConfigService_Delete_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "GetAll",
			Handler:       _AssignedTagsConfigService_GetAll_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "Subscribe",
			Handler:       _AssignedTagsConfigService_Subscribe_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "arista/studio.v1/services.gen.proto",
}

// InputsServiceClient is the client API for InputsService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type InputsServiceClient interface {
	GetOne(ctx context.Context, in *InputsRequest, opts ...grpc.CallOption) (*InputsResponse, error)
	GetAll(ctx context.Context, in *InputsStreamRequest, opts ...grpc.CallOption) (InputsService_GetAllClient, error)
	Subscribe(ctx context.Context, in *InputsStreamRequest, opts ...grpc.CallOption) (InputsService_SubscribeClient, error)
}

type inputsServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewInputsServiceClient(cc grpc.ClientConnInterface) InputsServiceClient {
	return &inputsServiceClient{cc}
}

func (c *inputsServiceClient) GetOne(ctx context.Context, in *InputsRequest, opts ...grpc.CallOption) (*InputsResponse, error) {
	out := new(InputsResponse)
	err := c.cc.Invoke(ctx, "/arista.studio.v1.InputsService/GetOne", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *inputsServiceClient) GetAll(ctx context.Context, in *InputsStreamRequest, opts ...grpc.CallOption) (InputsService_GetAllClient, error) {
	stream, err := c.cc.NewStream(ctx, &InputsService_ServiceDesc.Streams[0], "/arista.studio.v1.InputsService/GetAll", opts...)
	if err != nil {
		return nil, err
	}
	x := &inputsServiceGetAllClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type InputsService_GetAllClient interface {
	Recv() (*InputsStreamResponse, error)
	grpc.ClientStream
}

type inputsServiceGetAllClient struct {
	grpc.ClientStream
}

func (x *inputsServiceGetAllClient) Recv() (*InputsStreamResponse, error) {
	m := new(InputsStreamResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *inputsServiceClient) Subscribe(ctx context.Context, in *InputsStreamRequest, opts ...grpc.CallOption) (InputsService_SubscribeClient, error) {
	stream, err := c.cc.NewStream(ctx, &InputsService_ServiceDesc.Streams[1], "/arista.studio.v1.InputsService/Subscribe", opts...)
	if err != nil {
		return nil, err
	}
	x := &inputsServiceSubscribeClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type InputsService_SubscribeClient interface {
	Recv() (*InputsStreamResponse, error)
	grpc.ClientStream
}

type inputsServiceSubscribeClient struct {
	grpc.ClientStream
}

func (x *inputsServiceSubscribeClient) Recv() (*InputsStreamResponse, error) {
	m := new(InputsStreamResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// InputsServiceServer is the server API for InputsService service.
// All implementations must embed UnimplementedInputsServiceServer
// for forward compatibility
type InputsServiceServer interface {
	GetOne(context.Context, *InputsRequest) (*InputsResponse, error)
	GetAll(*InputsStreamRequest, InputsService_GetAllServer) error
	Subscribe(*InputsStreamRequest, InputsService_SubscribeServer) error
	mustEmbedUnimplementedInputsServiceServer()
}

// UnimplementedInputsServiceServer must be embedded to have forward compatible implementations.
type UnimplementedInputsServiceServer struct {
}

func (UnimplementedInputsServiceServer) GetOne(context.Context, *InputsRequest) (*InputsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetOne not implemented")
}
func (UnimplementedInputsServiceServer) GetAll(*InputsStreamRequest, InputsService_GetAllServer) error {
	return status.Errorf(codes.Unimplemented, "method GetAll not implemented")
}
func (UnimplementedInputsServiceServer) Subscribe(*InputsStreamRequest, InputsService_SubscribeServer) error {
	return status.Errorf(codes.Unimplemented, "method Subscribe not implemented")
}
func (UnimplementedInputsServiceServer) mustEmbedUnimplementedInputsServiceServer() {}

// UnsafeInputsServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to InputsServiceServer will
// result in compilation errors.
type UnsafeInputsServiceServer interface {
	mustEmbedUnimplementedInputsServiceServer()
}

func RegisterInputsServiceServer(s grpc.ServiceRegistrar, srv InputsServiceServer) {
	s.RegisterService(&InputsService_ServiceDesc, srv)
}

func _InputsService_GetOne_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InputsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InputsServiceServer).GetOne(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/arista.studio.v1.InputsService/GetOne",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InputsServiceServer).GetOne(ctx, req.(*InputsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _InputsService_GetAll_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(InputsStreamRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(InputsServiceServer).GetAll(m, &inputsServiceGetAllServer{stream})
}

type InputsService_GetAllServer interface {
	Send(*InputsStreamResponse) error
	grpc.ServerStream
}

type inputsServiceGetAllServer struct {
	grpc.ServerStream
}

func (x *inputsServiceGetAllServer) Send(m *InputsStreamResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _InputsService_Subscribe_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(InputsStreamRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(InputsServiceServer).Subscribe(m, &inputsServiceSubscribeServer{stream})
}

type InputsService_SubscribeServer interface {
	Send(*InputsStreamResponse) error
	grpc.ServerStream
}

type inputsServiceSubscribeServer struct {
	grpc.ServerStream
}

func (x *inputsServiceSubscribeServer) Send(m *InputsStreamResponse) error {
	return x.ServerStream.SendMsg(m)
}

// InputsService_ServiceDesc is the grpc.ServiceDesc for InputsService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var InputsService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "arista.studio.v1.InputsService",
	HandlerType: (*InputsServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetOne",
			Handler:    _InputsService_GetOne_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "GetAll",
			Handler:       _InputsService_GetAll_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "Subscribe",
			Handler:       _InputsService_Subscribe_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "arista/studio.v1/services.gen.proto",
}

// InputsConfigServiceClient is the client API for InputsConfigService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type InputsConfigServiceClient interface {
	GetOne(ctx context.Context, in *InputsConfigRequest, opts ...grpc.CallOption) (*InputsConfigResponse, error)
	GetAll(ctx context.Context, in *InputsConfigStreamRequest, opts ...grpc.CallOption) (InputsConfigService_GetAllClient, error)
	Subscribe(ctx context.Context, in *InputsConfigStreamRequest, opts ...grpc.CallOption) (InputsConfigService_SubscribeClient, error)
	Set(ctx context.Context, in *InputsConfigSetRequest, opts ...grpc.CallOption) (*InputsConfigSetResponse, error)
	Delete(ctx context.Context, in *InputsConfigDeleteRequest, opts ...grpc.CallOption) (*InputsConfigDeleteResponse, error)
}

type inputsConfigServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewInputsConfigServiceClient(cc grpc.ClientConnInterface) InputsConfigServiceClient {
	return &inputsConfigServiceClient{cc}
}

func (c *inputsConfigServiceClient) GetOne(ctx context.Context, in *InputsConfigRequest, opts ...grpc.CallOption) (*InputsConfigResponse, error) {
	out := new(InputsConfigResponse)
	err := c.cc.Invoke(ctx, "/arista.studio.v1.InputsConfigService/GetOne", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *inputsConfigServiceClient) GetAll(ctx context.Context, in *InputsConfigStreamRequest, opts ...grpc.CallOption) (InputsConfigService_GetAllClient, error) {
	stream, err := c.cc.NewStream(ctx, &InputsConfigService_ServiceDesc.Streams[0], "/arista.studio.v1.InputsConfigService/GetAll", opts...)
	if err != nil {
		return nil, err
	}
	x := &inputsConfigServiceGetAllClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type InputsConfigService_GetAllClient interface {
	Recv() (*InputsConfigStreamResponse, error)
	grpc.ClientStream
}

type inputsConfigServiceGetAllClient struct {
	grpc.ClientStream
}

func (x *inputsConfigServiceGetAllClient) Recv() (*InputsConfigStreamResponse, error) {
	m := new(InputsConfigStreamResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *inputsConfigServiceClient) Subscribe(ctx context.Context, in *InputsConfigStreamRequest, opts ...grpc.CallOption) (InputsConfigService_SubscribeClient, error) {
	stream, err := c.cc.NewStream(ctx, &InputsConfigService_ServiceDesc.Streams[1], "/arista.studio.v1.InputsConfigService/Subscribe", opts...)
	if err != nil {
		return nil, err
	}
	x := &inputsConfigServiceSubscribeClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type InputsConfigService_SubscribeClient interface {
	Recv() (*InputsConfigStreamResponse, error)
	grpc.ClientStream
}

type inputsConfigServiceSubscribeClient struct {
	grpc.ClientStream
}

func (x *inputsConfigServiceSubscribeClient) Recv() (*InputsConfigStreamResponse, error) {
	m := new(InputsConfigStreamResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *inputsConfigServiceClient) Set(ctx context.Context, in *InputsConfigSetRequest, opts ...grpc.CallOption) (*InputsConfigSetResponse, error) {
	out := new(InputsConfigSetResponse)
	err := c.cc.Invoke(ctx, "/arista.studio.v1.InputsConfigService/Set", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *inputsConfigServiceClient) Delete(ctx context.Context, in *InputsConfigDeleteRequest, opts ...grpc.CallOption) (*InputsConfigDeleteResponse, error) {
	out := new(InputsConfigDeleteResponse)
	err := c.cc.Invoke(ctx, "/arista.studio.v1.InputsConfigService/Delete", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// InputsConfigServiceServer is the server API for InputsConfigService service.
// All implementations must embed UnimplementedInputsConfigServiceServer
// for forward compatibility
type InputsConfigServiceServer interface {
	GetOne(context.Context, *InputsConfigRequest) (*InputsConfigResponse, error)
	GetAll(*InputsConfigStreamRequest, InputsConfigService_GetAllServer) error
	Subscribe(*InputsConfigStreamRequest, InputsConfigService_SubscribeServer) error
	Set(context.Context, *InputsConfigSetRequest) (*InputsConfigSetResponse, error)
	Delete(context.Context, *InputsConfigDeleteRequest) (*InputsConfigDeleteResponse, error)
	mustEmbedUnimplementedInputsConfigServiceServer()
}

// UnimplementedInputsConfigServiceServer must be embedded to have forward compatible implementations.
type UnimplementedInputsConfigServiceServer struct {
}

func (UnimplementedInputsConfigServiceServer) GetOne(context.Context, *InputsConfigRequest) (*InputsConfigResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetOne not implemented")
}
func (UnimplementedInputsConfigServiceServer) GetAll(*InputsConfigStreamRequest, InputsConfigService_GetAllServer) error {
	return status.Errorf(codes.Unimplemented, "method GetAll not implemented")
}
func (UnimplementedInputsConfigServiceServer) Subscribe(*InputsConfigStreamRequest, InputsConfigService_SubscribeServer) error {
	return status.Errorf(codes.Unimplemented, "method Subscribe not implemented")
}
func (UnimplementedInputsConfigServiceServer) Set(context.Context, *InputsConfigSetRequest) (*InputsConfigSetResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Set not implemented")
}
func (UnimplementedInputsConfigServiceServer) Delete(context.Context, *InputsConfigDeleteRequest) (*InputsConfigDeleteResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Delete not implemented")
}
func (UnimplementedInputsConfigServiceServer) mustEmbedUnimplementedInputsConfigServiceServer() {}

// UnsafeInputsConfigServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to InputsConfigServiceServer will
// result in compilation errors.
type UnsafeInputsConfigServiceServer interface {
	mustEmbedUnimplementedInputsConfigServiceServer()
}

func RegisterInputsConfigServiceServer(s grpc.ServiceRegistrar, srv InputsConfigServiceServer) {
	s.RegisterService(&InputsConfigService_ServiceDesc, srv)
}

func _InputsConfigService_GetOne_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InputsConfigRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InputsConfigServiceServer).GetOne(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/arista.studio.v1.InputsConfigService/GetOne",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InputsConfigServiceServer).GetOne(ctx, req.(*InputsConfigRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _InputsConfigService_GetAll_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(InputsConfigStreamRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(InputsConfigServiceServer).GetAll(m, &inputsConfigServiceGetAllServer{stream})
}

type InputsConfigService_GetAllServer interface {
	Send(*InputsConfigStreamResponse) error
	grpc.ServerStream
}

type inputsConfigServiceGetAllServer struct {
	grpc.ServerStream
}

func (x *inputsConfigServiceGetAllServer) Send(m *InputsConfigStreamResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _InputsConfigService_Subscribe_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(InputsConfigStreamRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(InputsConfigServiceServer).Subscribe(m, &inputsConfigServiceSubscribeServer{stream})
}

type InputsConfigService_SubscribeServer interface {
	Send(*InputsConfigStreamResponse) error
	grpc.ServerStream
}

type inputsConfigServiceSubscribeServer struct {
	grpc.ServerStream
}

func (x *inputsConfigServiceSubscribeServer) Send(m *InputsConfigStreamResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _InputsConfigService_Set_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InputsConfigSetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InputsConfigServiceServer).Set(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/arista.studio.v1.InputsConfigService/Set",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InputsConfigServiceServer).Set(ctx, req.(*InputsConfigSetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _InputsConfigService_Delete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InputsConfigDeleteRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InputsConfigServiceServer).Delete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/arista.studio.v1.InputsConfigService/Delete",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InputsConfigServiceServer).Delete(ctx, req.(*InputsConfigDeleteRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// InputsConfigService_ServiceDesc is the grpc.ServiceDesc for InputsConfigService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var InputsConfigService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "arista.studio.v1.InputsConfigService",
	HandlerType: (*InputsConfigServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetOne",
			Handler:    _InputsConfigService_GetOne_Handler,
		},
		{
			MethodName: "Set",
			Handler:    _InputsConfigService_Set_Handler,
		},
		{
			MethodName: "Delete",
			Handler:    _InputsConfigService_Delete_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "GetAll",
			Handler:       _InputsConfigService_GetAll_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "Subscribe",
			Handler:       _InputsConfigService_Subscribe_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "arista/studio.v1/services.gen.proto",
}

// StudioServiceClient is the client API for StudioService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type StudioServiceClient interface {
	GetOne(ctx context.Context, in *StudioRequest, opts ...grpc.CallOption) (*StudioResponse, error)
	GetAll(ctx context.Context, in *StudioStreamRequest, opts ...grpc.CallOption) (StudioService_GetAllClient, error)
	Subscribe(ctx context.Context, in *StudioStreamRequest, opts ...grpc.CallOption) (StudioService_SubscribeClient, error)
}

type studioServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewStudioServiceClient(cc grpc.ClientConnInterface) StudioServiceClient {
	return &studioServiceClient{cc}
}

func (c *studioServiceClient) GetOne(ctx context.Context, in *StudioRequest, opts ...grpc.CallOption) (*StudioResponse, error) {
	out := new(StudioResponse)
	err := c.cc.Invoke(ctx, "/arista.studio.v1.StudioService/GetOne", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *studioServiceClient) GetAll(ctx context.Context, in *StudioStreamRequest, opts ...grpc.CallOption) (StudioService_GetAllClient, error) {
	stream, err := c.cc.NewStream(ctx, &StudioService_ServiceDesc.Streams[0], "/arista.studio.v1.StudioService/GetAll", opts...)
	if err != nil {
		return nil, err
	}
	x := &studioServiceGetAllClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type StudioService_GetAllClient interface {
	Recv() (*StudioStreamResponse, error)
	grpc.ClientStream
}

type studioServiceGetAllClient struct {
	grpc.ClientStream
}

func (x *studioServiceGetAllClient) Recv() (*StudioStreamResponse, error) {
	m := new(StudioStreamResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *studioServiceClient) Subscribe(ctx context.Context, in *StudioStreamRequest, opts ...grpc.CallOption) (StudioService_SubscribeClient, error) {
	stream, err := c.cc.NewStream(ctx, &StudioService_ServiceDesc.Streams[1], "/arista.studio.v1.StudioService/Subscribe", opts...)
	if err != nil {
		return nil, err
	}
	x := &studioServiceSubscribeClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type StudioService_SubscribeClient interface {
	Recv() (*StudioStreamResponse, error)
	grpc.ClientStream
}

type studioServiceSubscribeClient struct {
	grpc.ClientStream
}

func (x *studioServiceSubscribeClient) Recv() (*StudioStreamResponse, error) {
	m := new(StudioStreamResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// StudioServiceServer is the server API for StudioService service.
// All implementations must embed UnimplementedStudioServiceServer
// for forward compatibility
type StudioServiceServer interface {
	GetOne(context.Context, *StudioRequest) (*StudioResponse, error)
	GetAll(*StudioStreamRequest, StudioService_GetAllServer) error
	Subscribe(*StudioStreamRequest, StudioService_SubscribeServer) error
	mustEmbedUnimplementedStudioServiceServer()
}

// UnimplementedStudioServiceServer must be embedded to have forward compatible implementations.
type UnimplementedStudioServiceServer struct {
}

func (UnimplementedStudioServiceServer) GetOne(context.Context, *StudioRequest) (*StudioResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetOne not implemented")
}
func (UnimplementedStudioServiceServer) GetAll(*StudioStreamRequest, StudioService_GetAllServer) error {
	return status.Errorf(codes.Unimplemented, "method GetAll not implemented")
}
func (UnimplementedStudioServiceServer) Subscribe(*StudioStreamRequest, StudioService_SubscribeServer) error {
	return status.Errorf(codes.Unimplemented, "method Subscribe not implemented")
}
func (UnimplementedStudioServiceServer) mustEmbedUnimplementedStudioServiceServer() {}

// UnsafeStudioServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to StudioServiceServer will
// result in compilation errors.
type UnsafeStudioServiceServer interface {
	mustEmbedUnimplementedStudioServiceServer()
}

func RegisterStudioServiceServer(s grpc.ServiceRegistrar, srv StudioServiceServer) {
	s.RegisterService(&StudioService_ServiceDesc, srv)
}

func _StudioService_GetOne_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StudioRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StudioServiceServer).GetOne(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/arista.studio.v1.StudioService/GetOne",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StudioServiceServer).GetOne(ctx, req.(*StudioRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _StudioService_GetAll_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(StudioStreamRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(StudioServiceServer).GetAll(m, &studioServiceGetAllServer{stream})
}

type StudioService_GetAllServer interface {
	Send(*StudioStreamResponse) error
	grpc.ServerStream
}

type studioServiceGetAllServer struct {
	grpc.ServerStream
}

func (x *studioServiceGetAllServer) Send(m *StudioStreamResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _StudioService_Subscribe_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(StudioStreamRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(StudioServiceServer).Subscribe(m, &studioServiceSubscribeServer{stream})
}

type StudioService_SubscribeServer interface {
	Send(*StudioStreamResponse) error
	grpc.ServerStream
}

type studioServiceSubscribeServer struct {
	grpc.ServerStream
}

func (x *studioServiceSubscribeServer) Send(m *StudioStreamResponse) error {
	return x.ServerStream.SendMsg(m)
}

// StudioService_ServiceDesc is the grpc.ServiceDesc for StudioService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var StudioService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "arista.studio.v1.StudioService",
	HandlerType: (*StudioServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetOne",
			Handler:    _StudioService_GetOne_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "GetAll",
			Handler:       _StudioService_GetAll_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "Subscribe",
			Handler:       _StudioService_Subscribe_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "arista/studio.v1/services.gen.proto",
}

// StudioConfigServiceClient is the client API for StudioConfigService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type StudioConfigServiceClient interface {
	GetOne(ctx context.Context, in *StudioConfigRequest, opts ...grpc.CallOption) (*StudioConfigResponse, error)
	GetAll(ctx context.Context, in *StudioConfigStreamRequest, opts ...grpc.CallOption) (StudioConfigService_GetAllClient, error)
	Subscribe(ctx context.Context, in *StudioConfigStreamRequest, opts ...grpc.CallOption) (StudioConfigService_SubscribeClient, error)
	Set(ctx context.Context, in *StudioConfigSetRequest, opts ...grpc.CallOption) (*StudioConfigSetResponse, error)
	Delete(ctx context.Context, in *StudioConfigDeleteRequest, opts ...grpc.CallOption) (*StudioConfigDeleteResponse, error)
}

type studioConfigServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewStudioConfigServiceClient(cc grpc.ClientConnInterface) StudioConfigServiceClient {
	return &studioConfigServiceClient{cc}
}

func (c *studioConfigServiceClient) GetOne(ctx context.Context, in *StudioConfigRequest, opts ...grpc.CallOption) (*StudioConfigResponse, error) {
	out := new(StudioConfigResponse)
	err := c.cc.Invoke(ctx, "/arista.studio.v1.StudioConfigService/GetOne", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *studioConfigServiceClient) GetAll(ctx context.Context, in *StudioConfigStreamRequest, opts ...grpc.CallOption) (StudioConfigService_GetAllClient, error) {
	stream, err := c.cc.NewStream(ctx, &StudioConfigService_ServiceDesc.Streams[0], "/arista.studio.v1.StudioConfigService/GetAll", opts...)
	if err != nil {
		return nil, err
	}
	x := &studioConfigServiceGetAllClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type StudioConfigService_GetAllClient interface {
	Recv() (*StudioConfigStreamResponse, error)
	grpc.ClientStream
}

type studioConfigServiceGetAllClient struct {
	grpc.ClientStream
}

func (x *studioConfigServiceGetAllClient) Recv() (*StudioConfigStreamResponse, error) {
	m := new(StudioConfigStreamResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *studioConfigServiceClient) Subscribe(ctx context.Context, in *StudioConfigStreamRequest, opts ...grpc.CallOption) (StudioConfigService_SubscribeClient, error) {
	stream, err := c.cc.NewStream(ctx, &StudioConfigService_ServiceDesc.Streams[1], "/arista.studio.v1.StudioConfigService/Subscribe", opts...)
	if err != nil {
		return nil, err
	}
	x := &studioConfigServiceSubscribeClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type StudioConfigService_SubscribeClient interface {
	Recv() (*StudioConfigStreamResponse, error)
	grpc.ClientStream
}

type studioConfigServiceSubscribeClient struct {
	grpc.ClientStream
}

func (x *studioConfigServiceSubscribeClient) Recv() (*StudioConfigStreamResponse, error) {
	m := new(StudioConfigStreamResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *studioConfigServiceClient) Set(ctx context.Context, in *StudioConfigSetRequest, opts ...grpc.CallOption) (*StudioConfigSetResponse, error) {
	out := new(StudioConfigSetResponse)
	err := c.cc.Invoke(ctx, "/arista.studio.v1.StudioConfigService/Set", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *studioConfigServiceClient) Delete(ctx context.Context, in *StudioConfigDeleteRequest, opts ...grpc.CallOption) (*StudioConfigDeleteResponse, error) {
	out := new(StudioConfigDeleteResponse)
	err := c.cc.Invoke(ctx, "/arista.studio.v1.StudioConfigService/Delete", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// StudioConfigServiceServer is the server API for StudioConfigService service.
// All implementations must embed UnimplementedStudioConfigServiceServer
// for forward compatibility
type StudioConfigServiceServer interface {
	GetOne(context.Context, *StudioConfigRequest) (*StudioConfigResponse, error)
	GetAll(*StudioConfigStreamRequest, StudioConfigService_GetAllServer) error
	Subscribe(*StudioConfigStreamRequest, StudioConfigService_SubscribeServer) error
	Set(context.Context, *StudioConfigSetRequest) (*StudioConfigSetResponse, error)
	Delete(context.Context, *StudioConfigDeleteRequest) (*StudioConfigDeleteResponse, error)
	mustEmbedUnimplementedStudioConfigServiceServer()
}

// UnimplementedStudioConfigServiceServer must be embedded to have forward compatible implementations.
type UnimplementedStudioConfigServiceServer struct {
}

func (UnimplementedStudioConfigServiceServer) GetOne(context.Context, *StudioConfigRequest) (*StudioConfigResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetOne not implemented")
}
func (UnimplementedStudioConfigServiceServer) GetAll(*StudioConfigStreamRequest, StudioConfigService_GetAllServer) error {
	return status.Errorf(codes.Unimplemented, "method GetAll not implemented")
}
func (UnimplementedStudioConfigServiceServer) Subscribe(*StudioConfigStreamRequest, StudioConfigService_SubscribeServer) error {
	return status.Errorf(codes.Unimplemented, "method Subscribe not implemented")
}
func (UnimplementedStudioConfigServiceServer) Set(context.Context, *StudioConfigSetRequest) (*StudioConfigSetResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Set not implemented")
}
func (UnimplementedStudioConfigServiceServer) Delete(context.Context, *StudioConfigDeleteRequest) (*StudioConfigDeleteResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Delete not implemented")
}
func (UnimplementedStudioConfigServiceServer) mustEmbedUnimplementedStudioConfigServiceServer() {}

// UnsafeStudioConfigServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to StudioConfigServiceServer will
// result in compilation errors.
type UnsafeStudioConfigServiceServer interface {
	mustEmbedUnimplementedStudioConfigServiceServer()
}

func RegisterStudioConfigServiceServer(s grpc.ServiceRegistrar, srv StudioConfigServiceServer) {
	s.RegisterService(&StudioConfigService_ServiceDesc, srv)
}

func _StudioConfigService_GetOne_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StudioConfigRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StudioConfigServiceServer).GetOne(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/arista.studio.v1.StudioConfigService/GetOne",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StudioConfigServiceServer).GetOne(ctx, req.(*StudioConfigRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _StudioConfigService_GetAll_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(StudioConfigStreamRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(StudioConfigServiceServer).GetAll(m, &studioConfigServiceGetAllServer{stream})
}

type StudioConfigService_GetAllServer interface {
	Send(*StudioConfigStreamResponse) error
	grpc.ServerStream
}

type studioConfigServiceGetAllServer struct {
	grpc.ServerStream
}

func (x *studioConfigServiceGetAllServer) Send(m *StudioConfigStreamResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _StudioConfigService_Subscribe_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(StudioConfigStreamRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(StudioConfigServiceServer).Subscribe(m, &studioConfigServiceSubscribeServer{stream})
}

type StudioConfigService_SubscribeServer interface {
	Send(*StudioConfigStreamResponse) error
	grpc.ServerStream
}

type studioConfigServiceSubscribeServer struct {
	grpc.ServerStream
}

func (x *studioConfigServiceSubscribeServer) Send(m *StudioConfigStreamResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _StudioConfigService_Set_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StudioConfigSetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StudioConfigServiceServer).Set(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/arista.studio.v1.StudioConfigService/Set",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StudioConfigServiceServer).Set(ctx, req.(*StudioConfigSetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _StudioConfigService_Delete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StudioConfigDeleteRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StudioConfigServiceServer).Delete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/arista.studio.v1.StudioConfigService/Delete",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StudioConfigServiceServer).Delete(ctx, req.(*StudioConfigDeleteRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// StudioConfigService_ServiceDesc is the grpc.ServiceDesc for StudioConfigService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var StudioConfigService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "arista.studio.v1.StudioConfigService",
	HandlerType: (*StudioConfigServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetOne",
			Handler:    _StudioConfigService_GetOne_Handler,
		},
		{
			MethodName: "Set",
			Handler:    _StudioConfigService_Set_Handler,
		},
		{
			MethodName: "Delete",
			Handler:    _StudioConfigService_Delete_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "GetAll",
			Handler:       _StudioConfigService_GetAll_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "Subscribe",
			Handler:       _StudioConfigService_Subscribe_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "arista/studio.v1/services.gen.proto",
}
