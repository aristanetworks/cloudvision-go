// Copyright (c) 2023 Arista Networks, Inc.  All rights reserved.
// Use of this source code is governed by the Apache License 2.0
// that can be found in the COPYING file.

//
// Code generated by boomtown. DO NOT EDIT.
//

package connectivitymonitor

import "google.golang.org/grpc"

// Client composes the service clients within the connectivitymonitor package.
// This client can then be composed into a larger hierarchy for more complex clients.
//
// Because method names include the name of the Resource they operate on, the embedded
// clients are unnamed fields to reduce stutter.
//
// Included resources:
//   - Probe
//   - ProbeStats
type Client struct {
	Probe      ProbeServiceClient
	ProbeStats ProbeStatsServiceClient
}

// NewClient creates a new composed-client from the given connection.
func NewClient(conn grpc.ClientConnInterface) Client {
	return Client{
		Probe:      NewProbeServiceClient(conn),
		ProbeStats: NewProbeStatsServiceClient(conn),
	}
}

// Server aggregates the various server interfaces required by gRPC.
// The included resources are:
//   - Probe
//   - ProbeStats
type Server struct {
	Probe      ProbeServiceServer
	ProbeStats ProbeStatsServiceServer
}

// Register takes the given gRPC Server and registers our services with it.
func (s Server) Register(target *grpc.Server) {
	RegisterProbeServiceServer(target, s.Probe)
	RegisterProbeStatsServiceServer(target, s.ProbeStats)
}

// RegisterUnimplementeds adds unimplemented servers to the given gRPC Server
func RegisterUnimplementeds(target *grpc.Server) error {
	RegisterProbeServiceServer(target,
		UnimplementedProbeServiceServer{})
	RegisterProbeStatsServiceServer(target,
		UnimplementedProbeStatsServiceServer{})
	return nil
}

// HasKey returns whether the given Probe has a key provided in the model.
func (p *Probe) HasKey() bool {
	return p.GetKey() != nil
}

// HasKey returns whether the given ProbeRequest has a key provided in the request.
func (p *ProbeRequest) HasKey() bool {
	return p.GetKey() != nil
}

// HasKey returns whether the given ProbeStats has a key provided in the model.
func (p *ProbeStats) HasKey() bool {
	return p.GetKey() != nil
}

// HasKey returns whether the given ProbeStatsRequest has a key provided in the request.
func (p *ProbeStatsRequest) HasKey() bool {
	return p.GetKey() != nil
}

// PassesPartialEqFilter returns whether the ProbeKey matches the passed in filter.
// On a nil comparison, we consider it a pass. Otherwise, all set (non-nil, initialized)
// fields are expected to match their "sibling" field in the comparison. Any non-matching
// value is considered a mismatch of the filter.
func (p *ProbeKey) PassesPartialEqFilter(cmp *ProbeKey) bool {
	// gave nothing to filter on, consider it passing
	if cmp == nil {
		return true
	}

	if p == nil {
		return false
	}

	if cmp.DeviceId != nil {
		if p.DeviceId == nil {
			return false
		}
		if p.DeviceId.Value != cmp.DeviceId.Value {
			return false
		}
	}

	if cmp.Host != nil {
		if p.Host == nil {
			return false
		}
		if p.Host.Value != cmp.Host.Value {
			return false
		}
	}

	if cmp.Vrf != nil {
		if p.Vrf == nil {
			return false
		}
		if p.Vrf.Value != cmp.Vrf.Value {
			return false
		}
	}

	return true
}

// PassesPartialEqFilter returns whether the ProbeStatsKey matches the passed in filter.
// On a nil comparison, we consider it a pass. Otherwise, all set (non-nil, initialized)
// fields are expected to match their "sibling" field in the comparison. Any non-matching
// value is considered a mismatch of the filter.
func (p *ProbeStatsKey) PassesPartialEqFilter(cmp *ProbeStatsKey) bool {
	// gave nothing to filter on, consider it passing
	if cmp == nil {
		return true
	}

	if p == nil {
		return false
	}

	if cmp.DeviceId != nil {
		if p.DeviceId == nil {
			return false
		}
		if p.DeviceId.Value != cmp.DeviceId.Value {
			return false
		}
	}

	if cmp.Host != nil {
		if p.Host == nil {
			return false
		}
		if p.Host.Value != cmp.Host.Value {
			return false
		}
	}

	if cmp.Vrf != nil {
		if p.Vrf == nil {
			return false
		}
		if p.Vrf.Value != cmp.Vrf.Value {
			return false
		}
	}

	if cmp.SourceIntf != nil {
		if p.SourceIntf == nil {
			return false
		}
		if p.SourceIntf.Value != cmp.SourceIntf.Value {
			return false
		}
	}

	return true
}

// PassesPartialEqFilter returns whether the Probe matches the passed in filter.
// On a nil comparison, we consider it a pass. Otherwise, all set (non-nil, initialized)
// fields are expected to match their "sibling" field in the comparison. Any non-matching
// value is considered a mismatch of the filter.
func (p *Probe) PassesPartialEqFilter(cmp *Probe) bool {
	// if the resource is nil, there is nothing to send to the client
	if p == nil {
		return false
	}

	// gave nothing to filter on, consider it passing
	if cmp == nil {
		return true
	}

	if !p.Key.PassesPartialEqFilter(cmp.Key) {
		return false
	}

	if cmp.IpAddr != nil {
		if p.IpAddr == nil {
			return false
		}
		if p.IpAddr.Value != cmp.IpAddr.Value {
			return false
		}
	}

	if cmp.HostName != nil {
		if p.HostName == nil {
			return false
		}
		if p.HostName.Value != cmp.HostName.Value {
			return false
		}
	}

	if cmp.Description != nil {
		if p.Description == nil {
			return false
		}
		if p.Description.Value != cmp.Description.Value {
			return false
		}
	}

	return true
}

// MatchesAnyPartialEqFilter returns whether the receiver matches any filters in the given set.
func (p *Probe) MatchesAnyPartialEqFilter(filters []*Probe) bool {
	if len(filters) == 0 {
		return true
	}

	for _, filt := range filters {
		if p.PassesPartialEqFilter(filt) {
			return true
		}
	}

	return false
}

// PassesPartialEqFilter returns whether the ProbeStats matches the passed in filter.
// On a nil comparison, we consider it a pass. Otherwise, all set (non-nil, initialized)
// fields are expected to match their "sibling" field in the comparison. Any non-matching
// value is considered a mismatch of the filter.
func (p *ProbeStats) PassesPartialEqFilter(cmp *ProbeStats) bool {
	// if the resource is nil, there is nothing to send to the client
	if p == nil {
		return false
	}

	// gave nothing to filter on, consider it passing
	if cmp == nil {
		return true
	}

	if !p.Key.PassesPartialEqFilter(cmp.Key) {
		return false
	}

	if cmp.LatencyMillis != nil {
		if p.LatencyMillis == nil {
			return false
		}
		if p.LatencyMillis.Value != cmp.LatencyMillis.Value {
			return false
		}
	}

	if cmp.JitterMillis != nil {
		if p.JitterMillis == nil {
			return false
		}
		if p.JitterMillis.Value != cmp.JitterMillis.Value {
			return false
		}
	}

	if cmp.HttpResponseTimeMillis != nil {
		if p.HttpResponseTimeMillis == nil {
			return false
		}
		if p.HttpResponseTimeMillis.Value != cmp.HttpResponseTimeMillis.Value {
			return false
		}
	}

	if cmp.PacketLossPercent != nil {
		if p.PacketLossPercent == nil {
			return false
		}
		if p.PacketLossPercent.Value != cmp.PacketLossPercent.Value {
			return false
		}
	}

	if cmp.Error != nil {
		if p.Error == nil {
			return false
		}
		if p.Error.Value != cmp.Error.Value {
			return false
		}
	}

	return true
}

// MatchesAnyPartialEqFilter returns whether the receiver matches any filters in the given set.
func (p *ProbeStats) MatchesAnyPartialEqFilter(filters []*ProbeStats) bool {
	if len(filters) == 0 {
		return true
	}

	for _, filt := range filters {
		if p.PassesPartialEqFilter(filt) {
			return true
		}
	}

	return false
}
