---
# get CPS before full disk write
# do a full write of the disk
# get CPS after full disk write
#
# input:
#   write_disks -> list of Linux disk names
#   step -> name eg: check, verify etc
#   

- debug: msg="{{step}} begin"

- include: cps.yml cps_disks="{{ write_disks }}" keyname="{{step}}_begin_write_cps"

# start the async jobs
- name: "Start async full drive write" 
  command: "dd if=/dev/zero of=/dev/{{ item }} bs=1M oflag=direct"
  async: "{{ ASYNC_JOB_TIMEOUT }}"
  register: full_write
  poll: 0
  loop_control:
    label: "{{ item }}"
  with_items: "{{ write_disks }}"

- debug: var=full_write

# poll for async jobs
# write tests will fail with "No space left" error if the full drive
# is successfully written
- name: "Wait for async full drive writes to complete"
  async_status:
    jid: "{{ item.ansible_job_id }}"
  register: job_result
  with_items: "{{ full_write.results }}"
  until: job_result.finished
  loop_control:
    label: "{{ item._ansible_item_label }}"
  retries: "{{ ASYNC_JOB_POLL_RETRIES }}"
  delay: "{{ ASYNC_JOB_POLL_DELAY }}"
  ignore_errors: True

- set_fact:
    job_results: "{{ job_result.results if job_result is defined else [] }}"
 
# Fail this test if the jobs timeout since the jobs may actually
# be running on the server.
# Caller of this task file is responsible for handling failures here
- block:
    - fail: msg="Async write job has timedout {{ item._ansible_item_label }}"
      when: "{{ item.finished != 1 }}"
      with_items: "{{ job_results }}"
  rescue:
    - debug: var=job_results
    - fail: msg="Failing because one/more async jobs have timedout"

- debug: msg="All async jobs completed. JobResult={{ job_results }}"

- set_fact:
    name: "{{step}}_done"

- set_fact:
    disk_details: "{{ disk_details | combine( {item.item.item: { name: item.stderr | search('No space left') }}, recursive=True) }}"
  with_items: "{{ job_results }}"

- include: cps.yml cps_disks="{{ write_disks }}" keyname="{{step}}_end_write_cps"

- debug: msg="{{step}} completed"
...
