#!/usr/bin/env python
# Copyright (c) 2016 Arista Networks, Inc.  All rights reserved.
# Arista Networks, Inc. Confidential and Proprietary.

# ASB Authenticator: Wrapper script for "restore_server"
# ----------------------------------------------------------------------
# Collects FQDN placeholders in automation account which signals they are
# ready to be issued a ticket and issues ticket. Assumes this script is
# initiated as root by cron job

import MySQLdb
import subprocess
import glob
import os
import sys
import logging
import time

# Enable logging
LOGFILE = '/var/log/ASBAuthenticator.log'
logging.basicConfig( filename=LOGFILE,
                     format='[ASB Authenticator] %(asctime)s: %(message)s',
                     datefmt='%m/%d/%Y %H:%M:%S',
                     level=logging.DEBUG )

# Dir with all the placeholders (whitelist files)
WHITELIST_DIR = "/home/asb/"

# Dir with all the user home directories
HOME_DIR = "/home"

# FQDN of all servers to be authenticated should contain this
CONTAINS_DOMAIN = "aristanetworks.com"

# Constant in seconds for period which whitelist files are valid
# 24 hours/day * 3600 seconds/hour = 86400 seconds/day
WHITELIST_VALID_PERIOD = 86400

# ----------------------------------------------------------------------------------
# Utility Functions
def _connect():
   try:
      db = MySQLdb.connect( user="arastra",
                            db="datacenter",
                            host="mysql" )
      cs = db.cursor()
      return db, cs
   except MySQLdb.MySQLError:
      # If there were errors trying to connect to DB, early exit.
      logging.error( "Could not connect to datacenter DB. Aborting." )
      sys.exit( 1 )

def _disconnect( cursor, dbcon ):
   cursor.close()
   dbcon.close()

def fetch_servers_with_status( status, test=False ):
   # XXX: Testing not yet set up for more than whitelist verification
   # NOTE: If MySQL support added to testing, there is a need to update
   # the docker image used in testing or mocking on the host where the
   # test is being run (see ardc package for similar example to the latter)
   if test:
      return [ ("test", "aristanetworks.com") ]

   try:
      db, cs = _connect()

      stmt = "select name,domain from servers where status=\"%s\"" % ( status )
      cs.execute( stmt )
      rows = list( cs.fetchall() )

      _disconnect( cs, db )
      return rows
   except MySQLdb.MySQLError:
      # If there were errors while trying to get records, early exit.
      logging.error( "Could not fetch server records from servers table." )
      sys.exit( 1 )

def prune_whitelist( whitelist ):
   logging.info( "Checking for outdated whitelist files..." )

   pruned = []
   toDelete = []
   now = time.time()

   for f in whitelist:
      fPath = os.path.join( WHITELIST_DIR, f )
      if os.path.isdir( fPath ):
         # Ignore all directories
         continue

      fTime = os.path.getmtime( fPath )
      if now - fTime > WHITELIST_VALID_PERIOD:
         # Remove whitelist files which are older than a day
         toDelete.append( f )
      else:
         pruned.append( f )

   if len( toDelete ):
      logging.info( "Found %d outdated whitelist files to delete." % \
                    len( toDelete ) )
   else:
      logging.info( "No outdated whitelist files found." )

   for d in toDelete:
      try:
         os.remove( os.path.join( WHITELIST_DIR, d ) )
         logging.info( "Deleted expired whitelist file: %s" % d )
      except OSError as e:
         logging.error( "Failed to delete whitelist file: %s, ERROR: %s" % \
                        ( d, e.strerror ) )

   return pruned
# ----------------------------------------------------------------------------------
# Main
# ----------------------------------------------------------------------------------
def main():
   if "--test" in sys.argv:
      logging.info( "Running in test mode..." )
      TEST_MODE = True
   else:
      TEST_MODE = False

   logging.info( "Waking up - scanning for servers." )

   # Fetch all hosts that need P4 ticket issued
   hosts = fetch_servers_with_status( "auth", test=TEST_MODE )

   if hosts:
      # Full FQDN of servers that need ticket on datacenter.servers
      needTicket = [ ( "%s.%s" % ( name, domain ) ) for name, domain in hosts ]
      logging.info( "Servers in auth state: %s" % ( ', '.join( needTicket ) ) )

      # Get list of whitelisted FQDNs in ASB account
      whitelist = [ os.path.basename( p ) for p in glob.glob(
                    os.path.join( WHITELIST_DIR, "*" ) )
                    if p.endswith( CONTAINS_DOMAIN )  ]

      # Get rid of expired whitelist files
      whitelist = prune_whitelist( whitelist )

      # XXX: Testing not yet set up for more than whitelist verification
      # Thoughts on how to meaningfully incorporate restore_server script
      # are still needed. Returning here in order to not run the restore_server
      # logic while in test mode. 
      if TEST_MODE:
         logging.info( "Skipping ticketing for test mode..." )
         return

      # Get list of servers already authenticated, ie. servers that has user account
      preAuthServers = os.listdir( HOME_DIR )
      preAuthServers = [ sv for sv in preAuthServers if CONTAINS_DOMAIN in sv ]

      # Only authenicate servers that are either:
      #    (1) whitelisted, ie. have a whitelisted file in ASB account, OR
      #    (2) once authenticated, ie. have an user account on ticketserver, OR
      #    (3) currently not authenicated, ie. "a4 login" requires password.
      allowed = set( whitelist ).union( preAuthServers )
      authServers = set( needTicket ) & allowed

      for sv in authServers:
         # Checking if server is already authenticated, ie. (3)
         ret = subprocess.call( "P4USER=arastra timeout 30 a4 ssh %s a4 login" % sv,
                                shell=True )
         if not ret:
            logging.info( "Server %s already has ticket, skipping." % sv )
            continue

         # Issue ticket to server
         logging.info( "Attempting to issue ticket to %s" % sv )
         ret = subprocess.call( "timeout 60 /root/restore_server %s --log-file %s"\
                                % ( sv, LOGFILE ), shell=True )
         if ret:
            logging.error( ( "Could not issue ticket for %s - restore_server script "
                             "failed with error code %d" )  % ( sv, ret ) )
         else:
            if sv in whitelist:
               logging.info( "Newly issued ticket for %s" % sv )
               try:
                  # Remove the whitelist file after authentication
                  os.remove( os.path.join( WHITELIST_DIR, sv ) )
                  logging.info( "Removed whitelist file for %s" % sv )
               except OSError:
                  logging.error( "Could not remove whitelist file for %s" % sv )
            elif sv in preAuthServers:
               logging.info( "Re-issued ticket for %s" % sv )

   logging.info( "Going back to sleep." )



if __name__ == "__main__":
   main()
