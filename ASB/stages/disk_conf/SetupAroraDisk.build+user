#!/usr/bin/env python
# Copyright (c) 2012 Arista Networks, Inc.  All rights reserved.
# Arista Networks, Inc. Confidential and Proprietary.

####################################################################################
#                                                                                  #
#           NOTE: THIS IS A TEMPORARY COPY IN 2010.Arora/src/AroraConfig           #
#                                                                                  #
####################################################################################

import sys, os, re
import threading
import PartTools
import A4.Helpers

def removeAllFilesystems( mdstat, device ):
   """
   Try to clean up filesystems on the specified 'device'.

   1. Remove low level volume.  (Required?)
   2. Unmount any partitions on the device.
   3. Turn off any swap partitions on the device.
   4. Turn off any swap partitions on RAID set which contains the device.
   5. Remove the device from any RAID set which it is part of.
   """
   deviceName = device.split( "/" )[ -1 ]

   print "Removing all filesystems on %s" % device
   A4.Helpers.run( [ "/sbin/dmsetup", "remove_all" ] )

   for line in open( "/proc/mounts" ).readlines():
      if line.startswith( device ):
         A4.Helpers.run( [ "umount", "-l", line.split()[ 1 ] ], verbose=True )

   for line in open( "/proc/swaps" ).readlines():
      if line.startswith( device ):
         A4.Helpers.run( [ "swapoff", line.split()[ 0 ] ], verbose=True )

   #
   # Find any raid devices that have partitions of this device, and remove
   # them. If the raid consists completely of devices to be removed, then
   # stop/remove the raid.
   #

   # Disable RAIDed swap on this device
   for ( md, parts ) in mdstat.iteritems():
      mdDev = '/dev/%s' % md
      devices = [ part[ :3 ] for part in parts ] # Strip off partition number.
      if deviceName in devices:
         for line in open( "/proc/swaps" ).readlines():
            if line.startswith( mdDev ):
               A4.Helpers.run( [ 'swapoff', mdDev ], verbose=True )

   # Remove this device from the RAID sets
   for ( md, parts ) in mdstat.iteritems():
      mdDev = '/dev/%s' % md
      devices = [ part[ :3 ] for part in parts ] # Strip off partition number.

      if deviceName in devices:
         if os.path.exists( mdDev ):
            PartTools.stopRaid( mdDev )

         # Zero out the RAID superblocks to prevent the kernel
         # from adding the partiton back into a RAID set.
         for partName in parts:
            if partName.startswith( deviceName ):
               A4.Helpers.run(
                  [ 'mdadm', '--zero-superblock', '/dev/%s' % ( partName, ) ],
                  verbose=True )

   # Inform Kernel of the changes
   A4.Helpers.run( [ 'partprobe' ], verbose=True )


def parted( mdstat, device, script ):
   removeAllFilesystems( mdstat, device )
   msg = "Zero out the beginning of %s to remove old boot loader code and " + \
         "partition table, to avoid getting stuck on GRUB during reboot."
   print msg % device
   A4.Helpers.run( [ "dd", "if=/dev/zero", "of=%s" % device, "bs=2M", "count=1" ],
         captureStderr=True, verbose=True )
   PartTools.iparted( device, script )
   # Inform Kernel of the changes
   A4.Helpers.run( [ 'partprobe' ], verbose=True )


class Config( object ):
   def __init__( self, name, minDrives, maxDrives, helpText=None ):
      self.name = name
      self.minDrives = minDrives
      self.maxDrives = maxDrives
      self.helpText = helpText

      if self.maxDrives and self.maxDrives < self.minDrives:
         raise ValueError( "maxDrives can't be less than minDrives" )

   def main( self, mdstat, devices, args ):
      raise NotImplementedError

class ConfigPrimary( Config ):
   def __init__( self ):
      Config.__init__( self, 'primary', 1, 1,
            helpText="Configure the primary drive on an Arora server" )

   @staticmethod
   def partition( mdstat, device, biosBootPartition = False ):
      if biosBootPartition:
         parted( mdstat, device, """
            mklabel gpt
            mkpart grub 0% 2MB
            mkpart primary 2MB 20GB
            mkpart primary linux-swap 20GB 22GB
            mkpart primary 22GB -1s
            set 1 bios_grub on""" )
      else:
         parted( mdstat, device, """
            mklabel gpt
            mkpart primary 0% 20GB
            mkpart primary linux-swap 20GB 22GB
            mkpart primary 22GB -1s
            set 1 boot on""" )

   @staticmethod
   def partition4part( mdstat, device, biosBootPartition = False ):
      if biosBootPartition:
         parted( mdstat, device, """
            mklabel gpt
            mkpart grub 0% 2MB
            mkpart primary 2MB 20GB
            mkpart primary linux-swap 20GB 22GB
            mkpart primary 22GB 72GB
            mkpart primary 72GB -1s
            set 1 bios_grub on""" )
      else:
         parted( mdstat, device, """
            mklabel gpt
            mkpart primary 0% 20GB
            mkpart primary linux-swap 20GB 22GB
            mkpart primary 22GB 72GB
            mkpart primary 72GB -1s
            set 1 boot on""" )

   def main( self, mdstat, devices, args ):
      partno = 2 if args.bbp else 1
      self.partition( mdstat, devices[ 0 ], args.bbp )
      PartTools.mkfs( "%s%d" % ( devices[ 0 ], partno ), "/" )
      PartTools.mkswap( "%s%d" % ( devices[ 0 ], partno + 1 ), "SWAP" )
      PartTools.mkfs( "%s%d" % ( devices[ 0 ], partno + 2 ), "/persist" )

class ConfigMirroredPrimary( Config ):
   def __init__( self ):
      Config.__init__( self, 'mirroredPrimary', 2, 2,
            helpText="Configure 2 drives to be a raid mirror primary drive on "
            "an Arora server" )

   def main( self, mdstat, devices, args ):
      md = 2 if args.bbp else 1
      ConfigPrimary.partition( mdstat, devices[ 0 ], args.bbp )
      ConfigPrimary.partition( mdstat, devices[ 1 ], args.bbp )

      PartTools.mdCreate( "/dev/md%d" % md,
                [ "%s%d" % ( devices[ 0 ], md ) ,
                  "%s%d" % ( devices[ 1 ], md ) ], level="mirror",
                metadata="0.90" )
      PartTools.mdCreate( "/dev/md%d" % ( md + 1 ) ,
                [ "%s%d" % ( devices[ 0 ], md + 1 ),
                  "%s%d" % ( devices[ 1 ], md + 1 ) ], level="mirror" )
      PartTools.mdCreate( "/dev/md%d" % ( md + 2 ),
                [ "%s%d" % ( devices[ 0 ], md + 2 ),
                  "%s%d" % ( devices[ 1 ], md + 2 ) ], level="mirror" )
      PartTools.mkfs( "/dev/md%d" % md, "/" )
      PartTools.mkswap( "/dev/md%d" % ( md + 1 ), "SWAP" )
      PartTools.mkfs( "/dev/md%d" % ( md + 2 ), "/persist" )

class ConfigStriped3Drives( Config ):
   def __init__( self ):
      Config.__init__( self, 'striped3Drives', 3, 3,
            helpText="Configure 3 drives: make / and SWAP mirrored (RAID-1) "
               "and /persist a RAID-5 partition; use the rest of the space "
               "for a striped (RAID-0) /persist2 partition." )

   def main( self, mdstat, devices, args ):
      md = 2 if args.bbp else 1

      for d in devices:
         ConfigPrimary.partition4part( mdstat, d, args.bbp )

      PartTools.mdCreate( "/dev/md%d" % md,
                [ "%s%d" % ( devices[ 0 ], md ) ,
                  "%s%d" % ( devices[ 1 ], md ) ,
                  "%s%d" % ( devices[ 2 ], md ) ],
                level="mirror", metadata="0.90" )
      PartTools.mdCreate( "/dev/md%d" % ( md + 1 ) ,
                [ "%s%d" % ( devices[ 0 ], md + 1 ),
                  "%s%d" % ( devices[ 1 ], md + 1 ),
                  "%s%d" % ( devices[ 2 ], md + 1 ) ],
                level="mirror" )
      PartTools.mdCreate( "/dev/md%d" % ( md + 2 ),
                [ "%s%d" % ( devices[ 0 ], md + 2 ),
                  "%s%d" % ( devices[ 1 ], md + 2 ),
                  "%s%d" % ( devices[ 2 ], md + 2 ) ],
                level="raid5" )
      PartTools.mdCreate( "/dev/md%d" % ( md + 3 ),
                [ "%s%d" % ( devices[ 0 ], md + 3 ),
                  "%s%d" % ( devices[ 1 ], md + 3 ),
                  "%s%d" % ( devices[ 2 ], md + 3 ) ],
                level="stripe" )

      PartTools.mkfs( "/dev/md%d" % md, "/" )
      PartTools.mkswap( "/dev/md%d" % ( md + 1 ), "SWAP" )
      PartTools.mkfs( "/dev/md%d" % ( md + 2 ), "/persist" )
      PartTools.mkfs( "/dev/md%d" % ( md + 3 ), "/persist2" )

class ConfigRaid5( Config ):
   def __init__( self ):
      Config.__init__( self, 'raid5', 3, 50,
            helpText="On the first 2 drives, make / and SWAP mirrored. Use the "
            "rest of the space for a raid5 /persist." )

   def main( self, mdstat, devices, args ):
      md = 2 if args.bbp else 1
      ConfigPrimary.partition( mdstat, devices[ 0 ], args.bbp )
      ConfigPrimary.partition( mdstat, devices[ 1 ], args.bbp )

      for d in devices[ 2: ]:
         parted( mdstat, d, """
                  mklabel gpt
                  mkpart primary 0GB -1s""" )

      PartTools.mdCreate( "/dev/md%d" % md, [ "%s%d" % ( devices[ 0 ], md ),
                                    "%s%d" % ( devices[ 1 ], md ) ],
                level="mirror", metadata="0.90" )
      PartTools.mdCreate( "/dev/md%d" % ( md + 1 ),
                [ "%s%d" % ( devices[ 0 ], md + 1 ),
                  "%s%d" % ( devices[ 1 ], md + 1 ) ], level="mirror" )
      PartTools.mdCreate( "/dev/md%d" % ( md + 2 ),
                [ "%s%d" % ( devices[ 0 ], md + 2 ),
                  "%s%d" % ( devices[ 1 ], md + 2 ) ] +
                [ "%s1" % d for d in devices[ 2: ] ], level="raid5" )
      PartTools.mkfs( "/dev/md%d" % md, "/" )
      PartTools.mkswap( "/dev/md%d" % ( md + 1 ), "SWAP" )
      PartTools.mkfs( "/dev/md%d" % ( md + 2 ), "/persist" )

class ConfigRaidV3Drives( Config ):
   def __init__( self ):
      Config.__init__( self, 'raidV3Drives', 3, 3,
            helpText="Configure 3 drives: make / and SWAP mirrored (RAID-1) "
               "partitions; use the rest of the space "
               "for a RAID-5 /persist partition." )

   def main( self, mdstat, devices, args ):
      md = 2 if args.bbp else 1

      for d in devices:
         ConfigPrimary.partition( mdstat, d, args.bbp )

      PartTools.mdCreate( "/dev/md%d" % md,
                [ "%s%d" % ( devices[ 0 ], md ) ,
                  "%s%d" % ( devices[ 1 ], md ) ,
                  "%s%d" % ( devices[ 2 ], md ) ],
                level="mirror", metadata="0.90" )
      PartTools.mdCreate( "/dev/md%d" % ( md + 1 ) ,
                [ "%s%d" % ( devices[ 0 ], md + 1 ),
                  "%s%d" % ( devices[ 1 ], md + 1 ),
                  "%s%d" % ( devices[ 2 ], md + 1 ) ],
                level="mirror" )
      PartTools.mdCreate( "/dev/md%d" % ( md + 2 ),
                [ "%s%d" % ( devices[ 0 ], md + 2 ),
                  "%s%d" % ( devices[ 1 ], md + 2 ),
                  "%s%d" % ( devices[ 2 ], md + 2 ) ],
                level="raid5" )

      PartTools.mkfs( "/dev/md%d" % md, "/" )
      PartTools.mkswap( "/dev/md%d" % ( md + 1 ), "SWAP" )
      PartTools.mkfs( "/dev/md%d" % ( md + 2 ), "/persist" )

class ConfigVm( Config ):
   """
   Configure virtual hard disks on an Arora server VM.  Requires that
   the VM is configured with two vHDs: a primary 20GB vHD for OS and
   swap and a secondary (big) vHD for /persist (user data).
   """
   def __init__( self ):
      Config.__init__( self, 'primaryVM', 2, 2,
            helpText="Configure the virtual disks on a Arora server VM" )

   def main( self, mdstat, devices, args ):
      # configure primary vHD
      parted( mdstat, devices[ 0 ], """
            mklabel gpt
            mkpart primary 0GB -2GB
            mkpart primary linux-swap 19.5GB -1s
            set 1 boot on""" )
      PartTools.mkfs( "%s1" % devices[ 0 ], "/" )
      PartTools.mkswap( "%s2" % devices[ 0 ], "SWAP" )
      # configure secondary vHD
      parted( mdstat, devices[ 1 ], """
            mklabel gpt
            mkpart primary 0GB -1s""" )
      PartTools.mkfs( "%s1" % devices[ 1 ], "/persist" )
      # there is no /persist2 file system

class ConfigPersistN( Config ):
   def __init__( self, n ):
      Config.__init__( self, 'persist%d' % n, 1, 1,
            helpText="Configure drive %d (/persist%d) on an Arora server" % (
               n, n ) )
      self.n = n

   def main( self, mdstat, devices, args ):
      parted( mdstat, devices[ 0 ], """
            mklabel gpt
            mkpart primary 0GB -1s""" )
      PartTools.mkfs( "%s1" % devices[ 0 ], "/persist%d" % self.n )

class ConfigPersist2( ConfigPersistN ):
   def __init__( self ):
      ConfigPersistN.__init__( self, 2 )

class ConfigPersist3( ConfigPersistN ):
   def __init__( self ):
      ConfigPersistN.__init__( self, 3 )

class ConfigPersist4( ConfigPersistN ):
   def __init__( self ):
      ConfigPersistN.__init__( self, 4 )

class ConfigPersist5( ConfigPersistN ):
   def __init__( self ):
      ConfigPersistN.__init__( self, 5 )

class ConfigPersist6( ConfigPersistN ):
   def __init__( self ):
      ConfigPersistN.__init__( self, 6 )

class ConfigPersist7( ConfigPersistN ):
   def __init__( self ):
      ConfigPersistN.__init__( self, 7 )

class ConfigPersist8( ConfigPersistN ):
   def __init__( self ):
      ConfigPersistN.__init__( self, 8 )

class ConfigBs2( Config ):
   def __init__( self ):
      Config.__init__( self, 'bs2', 2, 2,
                       helpText="Configure a 2-disk build server" )

   def main( self, mdstat, devices, args ):
      ConfigPrimary().main( mdstat, [ devices[ 0 ] ], args )
      ConfigPersist2().main( mdstat, [ devices[ 1 ] ], args )

class ConfigBs3( Config ):
   def __init__( self ):
      Config.__init__( self, 'bs3', 3, 3,
                       helpText="Configure a 3-disk build server" )

   def main( self, mdstat, devices, args ):
      ConfigMirroredPrimary().main( mdstat, devices[ :2 ], args )
      ConfigPersist2().main( mdstat, [ devices[ 2 ] ], args )

class ConfigBuildOnly( Config ):
   def __init__( self ):
      Config.__init__( self, 'buildOnly', 3, 3,
                       helpText="Configure a 3-disk build-only server" )

   def main( self, mdstat, devices, args ):
      ConfigStriped3Drives().main( mdstat, devices, args )

class ConfigUserOnly( Config ):
   def __init__( self ):
      Config.__init__( self, 'userOnly', 3, 3,
                       helpText="Configure a 3-disk user-only server" )

   def main( self, mdstat, devices, args ):
      ConfigRaidV3Drives().main( mdstat, devices, args )

class ConfigStestOnly( Config ):
   def __init__( self ):
      Config.__init__( self, 'stestOnly', 2, 2,
            helpText="Configure a 2-disk stest server" )

   @staticmethod
   def partition( mdstat, device, biosBootPartition = False ):
      if biosBootPartition:
         parted( mdstat, device, """
            mklabel gpt
            mkpart grub 0% 2MB
            mkpart primary 2MB 20GB
            mkpart primary 20GB 276GB
            mkpart primary 276GB -1s
            set 1 bios_grub on""" )
      else:
         parted( mdstat, device, """
            mklabel gpt
            mkpart primary 0% 20GB
            mkpart primary 20GB 276GB
            mkpart primary 276GB -1s
            set 1 boot on""" )

   def main( self, mdstat, devices, args ):
      partno = 2 if args.bbp else 1
      self.partition( mdstat, devices[ 0 ], args.bbp )
      self.partition( mdstat, devices[ 1 ], args.bbp )
      PartTools.mdCreate( "/dev/md1",
                [ "%s%d" % ( devices[ 0 ], partno ) ,
                  "%s%d" % ( devices[ 1 ], partno ) ], level="mirror",
                metadata="0.90" )
      PartTools.mdCreate( "/dev/md2",
                [ "%s%d" % ( devices[ 0 ], partno + 1 ) ,
                  "%s%d" % ( devices[ 1 ], partno + 1 ) ], level="mirror" )
      PartTools.mdCreate( "/dev/md3",
                [ "%s%d" % ( devices[ 0 ], partno + 2 ) ,
                  "%s%d" % ( devices[ 1 ], partno + 2 ) ], level="0" )
      PartTools.mkfs( "/dev/md1", "/" )
      PartTools.mkfs( "/dev/md2", "/persist" )
      PartTools.mkfs( "/dev/md3", "/persist2" )

class ConfigSwiftPrimary( Config ):
   def __init__( self ):
      Config.__init__( self, 'swiftPrimary', 1, 1, helpText="Configure a primary"
                       " swift drive (partition only)" )

   def main( self, mdstat, devices, args ):
      ConfigSwift.partitionPrimary( mdstat, devices[ 0 ], args.bbp )
      partno = 5 if args.bbp else 4
      PartTools.mkxfs( "%s%d" % ( devices[ 0 ], partno ), "NewSwiftDisk" )

class ConfigSwiftSecondary( Config ):
   def __init__( self ):
      Config.__init__( self, 'swiftSecondary', 1, 1, helpText="Configure a secondary"
                       " swift drive (partition only)" )

   def main( self, mdstat, devices, args ):
      ConfigSwift.partitionSecondary( mdstat, devices[ 0 ] )
      PartTools.mkxfs( "%s1" % devices[ 0 ], "NewSwiftDisk" )

class ConfigSwift( Config ):
   def __init__( self ):
      Config.__init__( self, 'swift', 2, None,
                       helpText="Configure 2 or more drives as a swift server" )

   @staticmethod
   def partitionPrimary( mdstat, device, biosBootPartition = False ):
      if biosBootPartition:
         parted( mdstat, device, """
            mklabel gpt
            mkpart grub 0% 2MB
            mkpart primary 2MB 20GB
            mkpart primary linux-swap 20GB 22GB
            mkpart primary 22GB 42GB
            mkpart primary xfs 42GB -1s
            set 1 bios_grub on""" )
      else:
         parted( mdstat, device, """
            mklabel gpt
            mkpart primary 0GB 20GB
            mkpart primary linux-swap 20GB 22GB
            mkpart primary 22GB 42GB
            mkpart primary xfs 42GB -1s
            set 1 boot on""" )

   @staticmethod
   def partitionSecondary( mdstat, device ):
      parted( mdstat, device, """
            mklabel gpt
            mkpart primary xfs 2048s -1s""" )

   def main( self, mdstat, devices, args ):
      offset = 1 if args.bbp else 0
      ConfigSwift.partitionPrimary( mdstat, devices[ 0 ], args.bbp )
      ConfigSwift.partitionPrimary( mdstat, devices[ 1 ], args.bbp )
      PartTools.mkxfs( "%s%d" % ( devices[ 0 ], offset + 4 ), "d1" )
      PartTools.mkxfs( "%s%d" % ( devices[ 1 ], offset + 4 ), "d2" )

      PartTools.mdCreate( "/dev/md1",
                          [ "%s%d" % ( devices[ 0 ], offset + 1 ),
                            "%s%d" % ( devices[ 1 ], offset + 1 ) ],
                          level="mirror", metadata="0.90" )
      PartTools.mdCreate( "/dev/md2",
                          [ "%s%d" % ( devices[ 0 ], offset + 2 ),
                            "%s%d" % ( devices[ 1 ], offset + 2 ) ],
                          level="mirror" )
      PartTools.mdCreate( "/dev/md3",
                          [ "%s%d" % ( devices[ 0 ], offset + 3 ),
                            "%s%d" % ( devices[ 1 ], offset + 3 ) ],
                          level="mirror" )
      PartTools.mkfs( "/dev/md1", "/" )
      PartTools.mkswap( "/dev/md2", "SWAP" )
      PartTools.mkfs( "/dev/md3", "/persist" )
      for device in devices[ 2: ]:
         ConfigSwift.partitionSecondary( mdstat, device )
         PartTools.mkxfs( "%s1" % device, "d%d" % ( devices.index( device ) + 1 ) )

class ParallelConfig( Config ):
   def __init__( self, *args, **kwargs ):
      super( ParallelConfig, self ).__init__( *args, **kwargs )

   def runInParallel( self, *threads ):
      for thread in threads:
         thread.start()
      print "Started %d threads" % len( threads )
      for thread in threads:
         thread.join()

   def main( self, mdstat, devices, args ):
      raise NotImplementedError

class ConfigHadoop( ParallelConfig ):
   def __init__( self ):
      super( ConfigHadoop, self ).__init__( 'hadoop', 8, 8,
            helpText="Configure the 8 disks of a Hadoop server" )

   def main( self, mdstat, devices, args ):
      self.runInParallel(
         threading.Thread( target=self._main,
                           args=( mdstat, [ devices[ 0 ] ], args ) ),
         threading.Thread( target=ConfigPersist2().main,
                           args=( mdstat, [ devices[ 1 ] ], args ) ),
         threading.Thread( target=ConfigPersist3().main,
                           args=( mdstat, [ devices[ 2 ] ], args ) ),
         threading.Thread( target=ConfigPersist4().main,
                           args=( mdstat, [ devices[ 3 ] ], args ) ),
         threading.Thread( target=ConfigPersist5().main,
                           args=( mdstat, [ devices[ 4 ] ], args ) ),
         threading.Thread( target=ConfigPersist6().main,
                           args=( mdstat, [ devices[ 5 ] ], args ) ),
         threading.Thread( target=ConfigPersist7().main,
                           args=( mdstat, [ devices[ 6 ] ], args ) ),
         threading.Thread( target=ConfigPersist8().main,
                           args=( mdstat, [ devices[ 7 ] ], args ) ),
      )

   @staticmethod
   def partition( mdstat, device ):
      parted( mdstat, device, """
            mklabel gpt
            mkpart primary 0GB 20GB
            mkpart primary 20GB -1s
            set 1 boot on""" )

   def _main( self, mdstat, devices, args ):
      self.partition( mdstat, devices[ 0 ] )
      PartTools.mkfs( "%s1" % devices[ 0 ], "/" )
      PartTools.mkfs( "%s2" % devices[ 0 ], "/persist" )

def main( args ):
   modes = (
         ConfigPrimary(),
         ConfigHadoop(),
         ConfigMirroredPrimary(),
         ConfigPersist2(),
         ConfigRaid5(),
         ConfigBs2(),
         ConfigBs3(),
         ConfigBuildOnly(),
         ConfigUserOnly(),
         ConfigStestOnly(),
         ConfigSwift(),
         ConfigSwiftPrimary(),
         ConfigSwiftSecondary(),
         ConfigVm()
         )
   import argparse
   parser = argparse.ArgumentParser(
         description='Prepare hard disks for an Arora install.' )
   parser.add_argument( '--yes', action='store_true', help='I am sure' )
   parser.add_argument( '-f', '--force', action='store_true', help='Bypass checks' )
   parser.add_argument( '--bbp', action='store_true',
                        help='Create an extra BIOS BOOT partition for GRUB 2.0' )
   modeGroup = parser.add_mutually_exclusive_group()
   for mode in modes:
      modeGroup.add_argument( '--%s' % mode.name, action='store_true',
            help=mode.helpText )
   parser.add_argument( 'device', nargs='*', help='Block devices.' )
   args = parser.parse_args( args )

   mode = None
   for modeOption in modes:
      if getattr( args, modeOption.name ):
         mode = modeOption
   if not mode:
      parser.error( "You must pick one of the mode options." )

   drives = len( args.device )
   if drives < mode.minDrives or ( mode.maxDrives and drives > mode.maxDrives ):
      error = "Mode %s requires you specify %s block devices"
      if mode.minDrives == mode.maxDrives:
         error %= ( mode.name, "exactly %d" % mode.minDrives )
      elif mode.maxDrives:
         error %= ( mode.name, "%d to %d" % ( mode.minDrives, mode.maxDrives ) )
      else:
         error %= ( mode.name, "at least %d" % mode.minDrives )
      parser.error( error )

   if not args.force:
      for device in args.device:
         try:
            A4.Helpers.run( [ "test", "-b", device ] )
         except A4.Helpers.SystemCommandError:
            parser.error( "%s isn't a valid block device" % device )

   if not args.yes:
      parser.error( "WARNING: You are about to initialize %s, destroying their "
            "existing contents; use --yes flag if this is what you want to do." %
            ", ".join( args.device ) )

   if not args.force and os.geteuid() != 0:
      sys.exit( "Must be run as root." )

   #
   # Collect RAID info before we start changing it.  Because once we run
   # "mdadm --stop" on a RAID set the info isn't accessable any more.
   #
   # md1 : active raid1 sdb1[1] sda1[0]
   # md2 : active raid1 sdb2[1] sda2[0]
   # md3 : active raid1 sdb3[1] sda3[0]
   #
   mdstat = {}
   for line in open( "/proc/mdstat" ).readlines():
      # unfortunately this reg-ex does not always work since
      # /proc/mdstat output is different when, for example
      # the RAID is being rebuilt. It shows the
      # progress and this sometimes confuses the code.
      # TODO : need to make this code more robust.
      m = re.match( r"(md\d+)\s+:\s+.* raid\d+ (.*)", line )
      if not m:
         continue

      md = m.group( 1 )
      mdParts = m.group( 2 ).split()
      mdstat[ md ] = [ x.split( '[' )[ 0 ] for x in mdParts ]

   mode.main( mdstat, args.device, args )

if __name__ == '__main__':
   sys.exit( main( sys.argv[ 1: ] ) )
