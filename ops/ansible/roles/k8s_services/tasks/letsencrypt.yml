# Copyright (c) 2017 Arista Networks, Inc.  All rights reserved.
# Arista Networks, Inc. Confidential and Proprietary.
# Subject to Arista Networks, Inc.'s EULA.
# FOR INTERNAL USE ONLY. NOT FOR DISTRIBUTION.

---

# Deploy letsencrypt "automatic" mode
# This mode is for prod clusters.
# A prod cluster will take care of generating/renewing
# the let's encrypt certificates itself.
# In order to do this, a pod with nginx server and certbot must
# take care of generating/renewing the certs.
# When certs are generated/renewed, this pod will publish
# the certs as secrets to k8s
# TODO: We should decouple the secret publishing to a separate pod
#       so we have a better security
#       (nginx pod should not be able to access k8s cluster)
# TODO: We should move those things to kube-system or a new aeris-system namespace
#       so it's not visible from other pods
- name: deploy letsencrypt service
  when: letsencrypt_mode == "automatic"
  kubernetes:
    api_endpoint: 127.0.0.1:8001
    insecure: true
    state: apply
    inline_data: |
      apiVersion: v1
      kind: Service
      metadata:
        name: letsencrypt
        labels:
          app: letsencrypt
      spec:
        type: LoadBalancer
        ports:
        - name: web
          port: 80
        selector:
          app: letsencrypt

- name: create letsencrypt volume
  when: letsencrypt_mode == "automatic"
  kubernetes:
    api_endpoint: 127.0.0.1:8001
    insecure: true
    inline_data: |
      apiVersion: v1
      kind: PersistentVolume
      metadata:
        name: "letsencrypt-data-{{ groups.letsencrypt[0] | replace('.', '-') }}"
        annotations:
          "volume.alpha.kubernetes.io/node-affinity": '{
            "requiredDuringSchedulingIgnoredDuringExecution": {
              "nodeSelectorTerms": [
                { "matchExpressions": [
                  { "key": "kubernetes.io/hostname",
                    "operator": "In",
                    "values": [ "{{ groups.letsencrypt[0] }}" ]
                  }
                ]}
               ]}
              }'
      spec:
        capacity:
          storage: 100Mi
        accessModes:
        - ReadWriteOnce
        persistentVolumeReclaimPolicy: Retain
        storageClassName: letsencrypt-data
        local:
          path: {{ hostvars[groups.letsencrypt[0]]["letsencrypt_data_dir"] }}

- name: deploy letsencrypt certbot script
  when: letsencrypt_mode == "automatic"
  kubernetes:
    api_endpoint: 127.0.0.1:8001
    state: apply
    insecure: true
    inline_data: |
      apiVersion: v1
      kind: ConfigMap
      metadata:
        name: letsencrypt-start-script
      data:
        start.sh: |
          {% macro certbotstart() %}{% include "./roles/"+(role_path|basename)+"/files/certbot-start.sh" %}{% endmacro %}
      {{ certbotstart() | indent(4) }}

- name: add haproxy config for letsencrypt proxy port 80
  when: letsencrypt_mode == "automatic"
  kubernetes:
    api_endpoint: 127.0.0.1:8001
    state: apply
    insecure: true
    inline_data: |
      #jinja2: block_start_string: '[%', block_end_string: '%]', variable_start_string: '[[', variable_end_string: ']]'
      apiVersion: v1
      kind: ConfigMap
      metadata:
        name: letsencrypt-haproxy-config
      data:
        haproxy.toml: |
          # Copyright (c) 2017 Arista Networks, Inc.  All rights reserved.
          # Arista Networks, Inc. Confidential and Proprietary.
          # Subject to Arista Networks, Inc.'s EULA.
          # FOR INTERNAL USE ONLY. NOT FOR DISTRIBUTION.

          [template]
          src = "haproxy.cfg.tmpl"
          dest = "/etc/haproxy/haproxy.cfg"
          keys = [
            "/services/default",
            "/endpoints/default",
          ]

          check_cmd = "/usr/sbin/haproxy -c -f {{ .src }}"
          reload_cmd = "haproxy -f /etc/haproxy/haproxy.cfg -p /var/run/haproxy.pid -D -sf $(cat /var/run/haproxy.pid)"

        haproxy.cfg.tmpl: |
          # Copyright (c) 2017 Arista Networks, Inc.  All rights reserved.
          # Arista Networks, Inc. Confidential and Proprietary.
          # Subject to Arista Networks, Inc.'s EULA.
          # FOR INTERNAL USE ONLY. NOT FOR DISTRIBUTION.

          global
            daemon
            pidfile /var/run/haproxy.pid
            maxconn 128000

          defaults
            mode http
            timeout connect 5000ms
            timeout client 50000ms
            timeout client-fin 50000ms
            timeout server 50000ms

          listen stats
            bind 127.0.0.1:1234
            mode http
            stats enable
            stats uri /
            stats refresh 5s

          listen letsencrypt
            bind :80
            mode http
          {{- if exists "/endpoints/default/letsencrypt"}}
            {{- range $i, $subset := (json (getv "/endpoints/default/letsencrypt")).subsets }}
            {{- range $j, $addr := $subset.addresses }}
            {{- range $k, $port := $subset.ports }}
            server le_{{ $i }}_{{ $j }}_{{ $k }} {{$addr.ip}}:{{.port}}
            {{- end }}
            {{- end }}
            {{- end }}
          {{- end }}

# This pod will run on all the proxy public machines
# It will listen and answer all the http traffic (port 80)
# So there will be several instances of this pod.
# All the traffic will be redirected to the single instance let's encrypt pod
# All the 404 will redirect to https://www.arista.io
- name: deploy letsencrypt proxy daemonset for port 80
  when: letsencrypt_mode == "automatic"
  kubernetes:
    api_endpoint: 127.0.0.1:8001
    insecure: true
    state: apply
    inline_data: |
      apiVersion: extensions/v1beta1
      kind: DaemonSet
      metadata:
        name: letsencryptproxy
      spec:
        selector:
          matchLabels:
            letsencryptproxy: "true"
        template:
          metadata:
            name: letsencryptproxy
            # annotations:
            #   TODO: Add prometheus monitoring
            #   prometheus.io/scrape: "true"
            #   prometheus.io/port: "9201"
            labels:
              letsencryptproxy: "true"
          spec:
            nodeSelector:
              letsencryptproxy: "true"
            containers:
            - name: proxy
              image: aristanetworks/haproxy-confd
              imagePullPolicy: Always
              args:
                - -backend
                - kubernetes
                - -watch
                - "true"
                - -logtostderr
              ports:
                - name: http
                  containerPort: 80
                  hostPort: 80
              volumeMounts:
              - name: letsencrypt-haproxy-config
                mountPath: /etc/confd/templates/haproxy.cfg.tmpl
                subPath: haproxy.cfg.tmpl
              - name: letsencrypt-haproxy-config
                mountPath: /etc/confd/conf.d/haproxy.toml
                subPath: haproxy.toml
            volumes:
            - name: letsencrypt-haproxy-config
              configMap:
                name: letsencrypt-haproxy-config

# This pod will have only ONE instance
# It will answer all the public http (port 80) traffic.
# It is NOT exposed publicly, and it is proxied by the public http(80) proxies
# It will take care of generating/renewing the let's encrypt certificates
# and publishing them as secret in the k8s cluster.
# All the non-let's encrypt challenge hits will redirect to
# https://www.arista.com
- name: deploy letsencrypt Statefulset
  when: letsencrypt_mode == "automatic"
  kubernetes:
    api_endpoint: 127.0.0.1:8001
    insecure: true
    state: apply
    inline_data: |
      apiVersion: apps/v1beta1
      kind: StatefulSet
      metadata:
        name: letsencrypt
      spec:
        selector:
          matchLabels:
            app: letsencrypt
        replicas: 1
        template:
          metadata:
            labels:
              app: letsencrypt
          spec:
            tolerations:
            - key: "type"
              operator: "Equal"
              value: "critical"
              effect: "NoSchedule"
            containers:
            - name: letsencrypt
              image: aristanetworks/letsencrypt
              imagePullPolicy: Always
              args:
                - /start.sh
              env:
                - name: DOMAINS
                  value: >
                    ingest.{{ k8s_domain }}
                    registry.{{ k8s_infra_domain }}
              ports:
              - containerPort: 80
                name: http
                protocol: TCP
              volumeMounts:
              - mountPath: /etc/letsencrypt
                name: data
                subPath: letsencrypt
              - mountPath: /etc/nginx/sites-enabled
                name: data
                subPath: sites-enabled
              - mountPath: /start.sh
                name: letsencrypt-start-script
                subPath: start.sh
            volumes:
            - name: letsencrypt-start-script
              configMap:
                name: letsencrypt-start-script
                defaultMode: 0755
        volumeClaimTemplates:
        - metadata:
            name: data
          spec:
            accessModes: [ "ReadWriteOnce" ]
            storageClassName: letsencrypt-data
            resources:
              requests:
                storage: 100Mi

# Deploy letsencrypt "gcp" mode
# This mode is for dev and staging clusters.
# Those clusters are not exposed to internet so
# they can't generate/renew certs using certbot.
# The gcp is used for this.
# a service running in those clusters will retrieve the
# certs and publish them as secrets, simulating what the letsencrypt pod
# is doing in "automatic" mode.
- name: deploy gcp letsencrypt Deployment
  when: letsencrypt_mode == "gcp"
  kubernetes:
    api_endpoint: 127.0.0.1:8001
    insecure: true
    state: apply
    inline_data: |
      apiVersion: extensions/v1beta1
      kind: Deployment
      metadata:
        name: gcp-letsencrypt
      spec:
        selector:
          matchLabels:
            app: gcp-letsencrypt
        replicas: 1
        template:
          metadata:
            labels:
              app: gcp-letsencrypt
          spec:
            containers:
            - name: gcp-letsencrypt
              image: {{ registry_hostname }}k8s/gcp-letsencrypt
            securityContext:
              runAsUser: 1000
              fsGroup: 1000
