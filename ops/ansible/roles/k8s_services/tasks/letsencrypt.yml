# Copyright (c) 2017 Arista Networks, Inc.  All rights reserved.
# Arista Networks, Inc. Confidential and Proprietary.
# Subject to Arista Networks, Inc.'s EULA.
# FOR INTERNAL USE ONLY. NOT FOR DISTRIBUTION.

---

# Deploy letsencrypt "automatic" mode
# This mode is for prod clusters.
# A prod cluster will take care of generating/renewing
# the let's encrypt certificates itself.
# In order to do this, a pod with nginx server and certbot must
# take care of generating/renewing the certs.
# When certs are generated/renewed, this pod will publish
# the certs as secrets to k8s
# TODO: We should decouple the secret publishing to a separate pod
#       so we have a better security
#       (nginx pod should not be able to access k8s cluster)
# TODO: We should move those things to kube-system or a new aeris-system namespace
#       so it's not visible from other pods
- name: deploy letsencrypt service
  when: letsencrypt_mode == "automatic"
  kubernetes:
    api_endpoint: 127.0.0.1:8001
    insecure: true
    state: apply
    inline_data: |
      apiVersion: v1
      kind: Service
      metadata:
        name: letsencrypt
        labels:
          app: letsencrypt
      spec:
        type: LoadBalancer
        ports:
        - name: web
          port: 80
        selector:
          app: letsencrypt

- name: create letsencrypt volume
  when: letsencrypt_mode == "automatic"
  kubernetes:
    api_endpoint: 127.0.0.1:8001
    insecure: true
    inline_data: |
      apiVersion: v1
      kind: PersistentVolume
      metadata:
        name: "letsencrypt-data-{{ groups.letsencrypt[0] | replace('.', '-') }}"
        annotations:
          "volume.alpha.kubernetes.io/node-affinity": '{
            "requiredDuringSchedulingIgnoredDuringExecution": {
              "nodeSelectorTerms": [
                { "matchExpressions": [
                  { "key": "kubernetes.io/hostname",
                    "operator": "In",
                    "values": [ "{{ groups.letsencrypt[0] }}" ]
                  }
                ]}
               ]}
              }'
      spec:
        capacity:
          storage: 100Mi
        accessModes:
        - ReadWriteOnce
        persistentVolumeReclaimPolicy: Retain
        storageClassName: letsencrypt-data
        local:
          path: /data2/letsencrypt-data

- name: deploy letsencrypt certbot script
  when: letsencrypt_mode == "automatic"
  kubernetes:
    api_endpoint: 127.0.0.1:8001
    state: apply
    insecure: true
    inline_data: |
      apiVersion: v1
      kind: ConfigMap
      metadata:
        name: letsencrypt-start-script
      data:
        start.sh: |
          {% macro certbotstart() %}{% include "./roles/"+(role_path|basename)+"/files/certbot-start.sh" %}{% endmacro %}
      {{ certbotstart() | indent(4) }}

# This pod will have only ONE instance
# It will answer all the public http (port 80) traffic.
# It is NOT exposed publicly, and it is proxied by the public http(80) proxies
# It will take care of generating/renewing the let's encrypt certificates
# and publishing them as secret in the k8s cluster.
# All the non-let's encrypt challenge hits will redirect to
# https://www.arista.com
- name: deploy letsencrypt Statefulset
  when: letsencrypt_mode == "automatic"
  kubernetes:
    api_endpoint: 127.0.0.1:8001
    insecure: true
    state: apply
    inline_data: |
      apiVersion: apps/v1beta1
      kind: Statefulset
      metadata:
        name: letsencrypt
      spec:
        selector:
          matchLabels:
            app: letsencrypt
        replicas: 1
        template:
          metadata:
            labels:
              app: letsencrypt
            annotations:
              prometheus.io/scrape: 'true'
          spec:
            containers:
            - name: letsencrypt
              image: aristanetworks/letsencrypt
              args:
                - /start.sh
              env:
                - name: DOMAINS
                  value: >
                    ingest.{{ k8s_domain }}
                    registry.{{ k8s_infra_domain }}
              ports:
              - containerPort: 80
                name: http
                protocol: TCP
              volumeMounts:
              - mountPath: /etc/letsencrypt
                name: letsencrypt-data
                subPath: letsencrypt
              - mountPath: /etc/nginx/sites-enabled
                name: letsencrypt-data
                subPath: sites-enabled
              - mountPath: /start.sh
                name: letsencrypt-start-script
                subPath: start.sh
                defaultMode: 0744
            securityContext:
              runAsUser: 1000
              fsGroup: 1000
            volumes:
            - name: letsencrypt-start-script
              configMap:
                name: letsencrypt-start-script
        volumeClaimTemplates:
        - metadata:
            name: data
          spec:
            accessModes: [ "ReadWriteOnce" ]
            storageClassName: letsencrypt-data
            resources:
              requests:
                storage: 100Mi

- name: add haproxy config for letsencrypt proxy port 80
  when: letsencrypt_mode == "automatic"
  kubernetes:
    api_endpoint: 127.0.0.1:8001
    state: apply
    insecure: true
    inline_data: |
      apiVersion: v1
      kind: ConfigMap
      metadata:
        name: letsencrypt-haproxy-config
      data:
        haproxy.cfg: |
          # Copyright (c) 2017 Arista Networks, Inc.  All rights reserved.
          # Arista Networks, Inc. Confidential and Proprietary.
          # Subject to Arista Networks, Inc.'s EULA.
          # FOR INTERNAL USE ONLY. NOT FOR DISTRIBUTION.

          global
            daemon
            pidfile /var/run/haproxy.pid
            maxconn 128000

          defaults
            mode http
            timeout connect 5000ms
            timeout client 50000ms
            timeout client-fin 50000ms
            timeout server 50000ms
            # stats enable
            # stats uri /haproxyStats

          frontend httpfrontend
            bind *:80

          default_backend letsencrypt

          backend letsencrypt
            mode http
            server le letsencrypt:80

# This pod will run on all the proxy public machines
# It will listen and answer all the http traffic (port 80)
# So there will be several instances of this pod.
# All the traffic will be redirected to the single instance let's encrypt pod
# All the 404 will redirect to https://www.arista.io
- name: deploy letsencrypt proxy daemonset for port 80
  when: letsencrypt_mode == "automatic"
  kubernetes:
    api_endpoint: 127.0.0.1:8001
    insecure: true
    state: apply
    inline_data: |
      apiVersion: extensions/v1beta1
      kind: DaemonSet
      metadata:
        name: letsencrypt-proxy
      spec:
        selector:
          matchLabels:
            letsencrypt-proxy: true
        template:
          metadata:
            name: letsencrypt-proxy
            # annotations:
            #   TODO: Add prometheus monitoring
            #   prometheus.io/scrape: "true"
            #   prometheus.io/port: "9201"
            labels:
              letsencrypt-proxy: true
          spec:
            nodeSelector:
              role: proxy
            containers:
            - name: letsencrypt-proxy
              image: haproxy:1.7.9
              ports:
                - name: http
                  containerPort: 80
                  hostPort: 80
              volumeMounts:
              - name: letsencrypt-haproxy-config
                mountPath: /etc/haproxy/haproxy.cfg
                subPath: haproxy.cfg
            volumes:
            - name: letsencrypt-haproxy-config
              configMap:
                name: letsencrypt-haproxy-config

# Deploy letsencrypt "gcp" mode
# This mode is for dev and staging clusters.
# Those clusters are not exposed to internet so
# they can't generate/renew certs using certbot.
# The gcp is used for this.
# a service running in those clusters will retrieve the
# certs and publish them as secrets, simulating what the letsencrypt pod
# is doing in "automatic" mode.
- name: deploy gcp letsencrypt Deployment
  when: letsencrypt_mode == "gcp"
  kubernetes:
    api_endpoint: 127.0.0.1:8001
    insecure: true
    state: apply
    inline_data: |
      apiVersion: extensions/v1beta1
      kind: Deployment
      metadata:
        name: gcp-letsencrypt
      spec:
        selector:
          matchLabels:
            app: gcp-letsencrypt
        replicas: 1
        template:
          metadata:
            labels:
              app: gcp-letsencrypt
          spec:
            containers:
            - name: gcp-letsencrypt
              image: registry.docker.sjc.aristanetworks.com:5000/k8s/gcp-letsencrypt
            securityContext:
              runAsUser: 1000
              fsGroup: 1000
